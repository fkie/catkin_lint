{
    "docs": [
        {
            "location": "/",
            "text": "catkin_lint\n\n\nOverview\n\n\ncatkin_lint\n checks package configurations for the\n\ncatkin\n build system of\n\nROS\n. It runs a static analysis of the \npackage.xml\n\nand \nCMakeLists.txt\n files in your package, and it will detect and report a\nnumber of common problems.\n\n\nInstallation\n\n\nUbuntu\n\n\nPrebuilt packages are available from the official Ubuntu archive and the\n\nROS repository\n.\nIf you are using ROS Noetic on Ubuntu 20.04 or later, install \ncatkin_lint\n with\n\n\n$ sudo apt install catkin-lint\n\n\n\n\n\n\nNote\n\n\nStarting with Ubuntu 20.04, the package has been renamed. If you are using an older\nrelease, please run \nsudo apt install python-catkin-lint\n instead.\n\n\n\n\nAlternatively, you can use \nTimo's PPA\n on Launchpad,\nwhich will always ship the latest release:\n\n\n$ sudo add-apt-repository ppa:roehling/latest\n$ sudo apt update\n$ sudo apt install catkin-lint\n\n\n\n\nDebian\n\n\nPrebuilt packages are available from the official Debian archive. Install with\n\n\n$ sudo apt install catkin-lint\n\n\n\n\n\n\nNote\n\n\nFor Debian Buster, the package is named \npython-catkin-lint\n.\n\n\n\n\nDownload from PyPI\n\n\nYou can download and install \ncatkin_lint\n from the \nPython Package Index\n\nwith:\n\n\n$ sudo pip install catkin-lint\n\n\n\n\nInstall from Source\n\n\nYou can clone \ncatkin_lint\n from \nGitHub\n:\n\n\n$ git clone https://github.com/fkie/catkin_lint.git\n$ cd catkin_lint\n$ sudo python setup.py install\n\n\n\n\nRunning\n\n\nIf \ncatkin_lint\n is invoked with one or more paths as parameters, it\nsearches for packages recursively and checks all of them. Alternatively, the\n\n--pkg\n option can be used to add the path of a particular ROS package.\n\n\nIf neither paths nor packages are specified, \ncatkin_lint\n looks for a\npackage in the current working directory.\n\n\nA more detailed list of command line options can be obtained by running\n\n\n$ catkin_lint --help\n\n\n\n\nLimitations\n\n\ncatkin_lint\n works by emulating the way CMake processes your package\nduring a build. However, since it does not \nreally\n build anything,\nthe emulation is not perfect. For instance,\n\n\n\n\ncatkin_lint\n does not evaluate boolean expressions in \nif()\n clauses\n  There is some special purpose code to detect \nif(CATKIN_ENABLE_TESTING)\n blocks,\n  but in general, \ncatkin_lint\n will just execute all statements, even mutually exclusive\n  \nif()\n/\nelse()\n blocks.\n\n\ncatkin_lint\n uses mock values for \nfind_package()\n, \nfind_file()\n, and \nfind_library()\n\n  calls. That means that those function calls will always succeed and \"find\" something.\n\n\ncatkin_lint\n ignores \nfunction()\n definitions. It does, however, expand macros and\n  \nforeach()\n loops.\n\n\n\n\nDiagnostic Levels\n\n\ncatkin_lint\n has \nmessages\n in three different categories:\nerrors, warnings, and notices. The \n-W\n option controls which problems\nare reported to the user:\n\n\n\n\n-W0\n: only errors are reported\n\n\n-W1\n: errors and warnings are reported (this is the default)\n\n\n-W2\n: errors, warnings, and notices are reported\n\n\n\n\nNormally, \ncatkin_lint\n returns a non-zero exit code if and only\nif errors occurred. The \n--strict\n option causes \ncatkin_lint\n to\ntreat any reported problem as error. You can also customize the category\nfor particular diagnostics with \n--error ID\n, \n--warning ID\n, or\n\n--notice ID\n. You can also ignore messages entirely with \n--ignore ID\n.\n\n\nErrors\n\n\nErrors are severe enough to break the build and/or produce unintended\nside effects. Usually, they violate the rules outlined in the\n\ncatkin manual\n.\n\n\nWarnings\n\n\nPotential errors which may indicate a bug in your package but may be\njustified for reasons \ncatkin_lint\n cannot discern. Constructs which\ntrigger a warning can usually be modified in a way that is functionally\nequivalent but more robust.\n\n\nNotices\n\n\nIssues which are not objectionable from a technical view point but\nshould  be addressed to improve the quality of the package. Many notices\nhighlight violations of the recommendations and best practises from the\ncatkin manual.\n\n\nConfiguration files\n\n\nSince version 1.6.9, \ncatkin_lint\n can load settings from a configuration file.\nConfiguration files can be specified with the \n--config\n command line options.\nAdditionally, \ncatkin_lint\n will look in the following locations (in precedence order):\n\n\n\n\n.catkin_lint\n files in the \nROS_PACKAGE_PATH\n directories\n\n\n$XDG_CONFIG_HOME/catkin_lint\n (\n$XDG_CONFIG_HOME\n defaults to \n~/.config\n)\n\n\n~/.catkin_lint\n\n\n\n\nThe file is expected to be in an INI-style format with different sections.\nThe \n[catkin_lint]\n section may contain command line options.\nAll other sections are considered package names and will override the\nseverity of diagnostic messages.\nThe special wildcard section \n[*]\n applies to all packages.\n\n\nThe following example illustrates the configuration file format:\n\n\n[catkin_lint]\noutput = explain\ncolor = auto\npackage_path = /path/to/extra/packages\n\n[foo]\nmissing_catkin_depend = warning\nunknown_package = ignore\n\n\n[bar]\ndeprecated_cmd = default\n\n[*]\ndeprecated_cmd = error\nlaunch_depend = notice\n\n\n\nNote that the \ndeprecated_cmd\n override from the wildcard section applies to the package \nfoo\n,\nbut not to the package \nbar\n.",
            "title": "Home"
        },
        {
            "location": "/#catkin_lint",
            "text": "",
            "title": "catkin_lint"
        },
        {
            "location": "/#overview",
            "text": "catkin_lint  checks package configurations for the catkin  build system of ROS . It runs a static analysis of the  package.xml \nand  CMakeLists.txt  files in your package, and it will detect and report a\nnumber of common problems.",
            "title": "Overview"
        },
        {
            "location": "/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/#ubuntu",
            "text": "Prebuilt packages are available from the official Ubuntu archive and the ROS repository .\nIf you are using ROS Noetic on Ubuntu 20.04 or later, install  catkin_lint  with  $ sudo apt install catkin-lint   Note  Starting with Ubuntu 20.04, the package has been renamed. If you are using an older\nrelease, please run  sudo apt install python-catkin-lint  instead.   Alternatively, you can use  Timo's PPA  on Launchpad,\nwhich will always ship the latest release:  $ sudo add-apt-repository ppa:roehling/latest\n$ sudo apt update\n$ sudo apt install catkin-lint",
            "title": "Ubuntu"
        },
        {
            "location": "/#debian",
            "text": "Prebuilt packages are available from the official Debian archive. Install with  $ sudo apt install catkin-lint   Note  For Debian Buster, the package is named  python-catkin-lint .",
            "title": "Debian"
        },
        {
            "location": "/#download-from-pypi",
            "text": "You can download and install  catkin_lint  from the  Python Package Index \nwith:  $ sudo pip install catkin-lint",
            "title": "Download from PyPI"
        },
        {
            "location": "/#install-from-source",
            "text": "You can clone  catkin_lint  from  GitHub :  $ git clone https://github.com/fkie/catkin_lint.git\n$ cd catkin_lint\n$ sudo python setup.py install",
            "title": "Install from Source"
        },
        {
            "location": "/#running",
            "text": "If  catkin_lint  is invoked with one or more paths as parameters, it\nsearches for packages recursively and checks all of them. Alternatively, the --pkg  option can be used to add the path of a particular ROS package.  If neither paths nor packages are specified,  catkin_lint  looks for a\npackage in the current working directory.  A more detailed list of command line options can be obtained by running  $ catkin_lint --help",
            "title": "Running"
        },
        {
            "location": "/#limitations",
            "text": "catkin_lint  works by emulating the way CMake processes your package\nduring a build. However, since it does not  really  build anything,\nthe emulation is not perfect. For instance,   catkin_lint  does not evaluate boolean expressions in  if()  clauses\n  There is some special purpose code to detect  if(CATKIN_ENABLE_TESTING)  blocks,\n  but in general,  catkin_lint  will just execute all statements, even mutually exclusive\n   if() / else()  blocks.  catkin_lint  uses mock values for  find_package() ,  find_file() , and  find_library() \n  calls. That means that those function calls will always succeed and \"find\" something.  catkin_lint  ignores  function()  definitions. It does, however, expand macros and\n   foreach()  loops.",
            "title": "Limitations"
        },
        {
            "location": "/#diagnostic-levels",
            "text": "catkin_lint  has  messages  in three different categories:\nerrors, warnings, and notices. The  -W  option controls which problems\nare reported to the user:   -W0 : only errors are reported  -W1 : errors and warnings are reported (this is the default)  -W2 : errors, warnings, and notices are reported   Normally,  catkin_lint  returns a non-zero exit code if and only\nif errors occurred. The  --strict  option causes  catkin_lint  to\ntreat any reported problem as error. You can also customize the category\nfor particular diagnostics with  --error ID ,  --warning ID , or --notice ID . You can also ignore messages entirely with  --ignore ID .",
            "title": "Diagnostic Levels"
        },
        {
            "location": "/#errors",
            "text": "Errors are severe enough to break the build and/or produce unintended\nside effects. Usually, they violate the rules outlined in the catkin manual .",
            "title": "Errors"
        },
        {
            "location": "/#warnings",
            "text": "Potential errors which may indicate a bug in your package but may be\njustified for reasons  catkin_lint  cannot discern. Constructs which\ntrigger a warning can usually be modified in a way that is functionally\nequivalent but more robust.",
            "title": "Warnings"
        },
        {
            "location": "/#notices",
            "text": "Issues which are not objectionable from a technical view point but\nshould  be addressed to improve the quality of the package. Many notices\nhighlight violations of the recommendations and best practises from the\ncatkin manual.",
            "title": "Notices"
        },
        {
            "location": "/#configuration-files",
            "text": "Since version 1.6.9,  catkin_lint  can load settings from a configuration file.\nConfiguration files can be specified with the  --config  command line options.\nAdditionally,  catkin_lint  will look in the following locations (in precedence order):   .catkin_lint  files in the  ROS_PACKAGE_PATH  directories  $XDG_CONFIG_HOME/catkin_lint  ( $XDG_CONFIG_HOME  defaults to  ~/.config )  ~/.catkin_lint   The file is expected to be in an INI-style format with different sections.\nThe  [catkin_lint]  section may contain command line options.\nAll other sections are considered package names and will override the\nseverity of diagnostic messages.\nThe special wildcard section  [*]  applies to all packages.  The following example illustrates the configuration file format:  [catkin_lint]\noutput = explain\ncolor = auto\npackage_path = /path/to/extra/packages\n\n[foo]\nmissing_catkin_depend = warning\nunknown_package = ignore\n\n\n[bar]\ndeprecated_cmd = default\n\n[*]\ndeprecated_cmd = error\nlaunch_depend = notice  Note that the  deprecated_cmd  override from the wildcard section applies to the package  foo ,\nbut not to the package  bar .",
            "title": "Configuration files"
        },
        {
            "location": "/messages/",
            "text": "catkin_lint diagnostic messages\n\n\nThis is a list of all messages which might be shown by \ncatkin_lint\n.\nEach diagnostic has a unique ID (such as \ncatkin_order_violation\n),\nwhich you can use to disable certain messages, either with the command line option\n\n--ignore ID\n, or by adding a pragma line \n#catkin_lint: ignore ID\n at the beginning\nof the CMakeLists.txt file. As a third option, you can add a pragma line \n#catkin_lint: ignore_once ID\n\nright before the offending statement. Use this if you want to ignore a particular instance\nof a problem but still be notified if the same problem occurs someplace else. You may\nalso use \n#catkin_lint: report ID\n at any point to override a previous \nignore\n.\n\n\nSince version 1.5.4, you may also customize the severity with the command line options\n\n--error ID\n, \n--warning ID\n, or \n--notice ID\n. You can also add the pragma line\n\n#catkin_lint: skip\n in any \nif()\n, \nforeach()\n, or \nmacro()\n block, which will instruct\nthe parser to ignore all remaining commands in the block until the \nelse()\n, \nendif()\n,\n\nendforeach()\n, or \nendmacro()\n statement.\n\n\n'\npkg\n' in find_package(catkin) is not a catkin package\n\n\n\n\nID\n: no_catkin_component\n\n\nSeverity\n: error\n\n\nExplanation\n: The \nfind_package(catkin)\n call can list other catkin packages as dependencies with the COMPONENTS keyword. This is shorter than multiple \nfind_package()\n calls, but does not work for system dependencies.\n\n\n\n\ncmd\n() exports external \nscope\n path '\ndirectory\n'\n\n\n\n\nID\n: external_interface_path\n\n\nSeverity\n: warning\n\n\nExplanation\n: You have exported an include path as part of your interface for dependent targets, but that path does not belong to your package. You probably meant to use the PRIVATE scope if you merely need that include path for your build. If you actually wanted to export the path to your dependees, you hould be aware that target properties will be exported as fixed strings, meaning your installed package will break if that location changes for any reason. A more robust way would be to use \ntarget_link_libraries(\nscope\n)\n with the proper imported target instead.\n\n\n\n\ncmd\n() is called before find_package(catkin)\n\n\n\n\nID\n: catkin_order_violation\n\n\nSeverity\n: error\n\n\nExplanation\n: Catkin macros cannot be called before catkin has been configured with \nfind_package(catkin)\n.\n\n\n\n\ncmd\n() is not allowed in meta packages\n\n\n\n\nID\n: invalid_meta_command\n\n\nSeverity\n: error\n\n\nExplanation\n: Meta packages do not contain code or data and are merely dependency lists with very strict requirements for the format of the CMakeLists.txt file.\n\n\n\n\ncmd\n() needs missing directory '\ndirectory\n'\n\n\n\n\nID\n: missing_directory\n\n\nSeverity\n: error\n\n\nExplanation\n: This catkin command processes a particular directory which is missing from the package source folder.\n\n\n\n\ncmd\n() needs missing file '\nfile\n'\n\n\n\n\nID\n: missing_file\n\n\nSeverity\n: error\n\n\nExplanation\n: This catkin command processes a particular file which is missing from the package source folder.\n\n\n\n\ncmd\n() should be all lower-case\n\n\n\n\nID\n: cmd_case\n\n\nSeverity\n: notice\n\n\nExplanation\n: The catkin manual recommends that all commands be written in lower case.\n\n\n\n\ncmd\n() used without if(CATKIN_ENABLE_TESTING)\n\n\n\n\nID\n: unguarded_test_cmd\n\n\nSeverity\n: error\n\n\nExplanation\n: You have used a test command without properly guarding it by a \nif(CATKIN_ENABLE_TESTING)\n block.\n\n\n\n\ncmd\n() uses directory '\ndirectory\n' which is not in package\n\n\n\n\nID\n: external_directory\n\n\nSeverity\n: warning\n\n\nExplanation\n: This catkin command uses a directory which lies outside of the package source folder. While this may work in your particular setup, you cannot assume file locations in general. Use \nfind_path()\n to detect external locations insteed.\n\n\n\n\ncmd\n() uses file '\nfile\n' which is not in package\n\n\n\n\nID\n: external_file\n\n\nSeverity\n: error, warning\n\n\nExplanation\n: This catkin command uses a file which lies outside of the package source folder. While this may work in your particular setup, you cannot assume file locations in general. Use \nfind_file()\n to detect external locations insteed.\n\n\n\n\nexport\n plugin file '\nfile\n' is not installed to ${CATKIN_PACKAGE_SHARE_DESTINATION}\n\n\n\n\nID\n: uninstalled_plugin\n\n\nSeverity\n: error, warning\n\n\nExplanation\n: Your package can be used from the devel space but cannot be installed properly, because a plugin declaration file which is listed in your package.xml is not installed to the correct location.\n\n\n\n\nexport\n plugin file reference must start with '${prefix}/'\n\n\n\n\nID\n: plugin_export_prefix\n\n\nSeverity\n: error\n\n\nExplanation\n: The ${prefix} variable is carefully overloaded to work with both devel space and install space and must be used in all \n tags.\n\n\n\n\nexport\n plugin refers to missing file '\nfile\n'\n\n\n\n\nID\n: missing_plugin\n\n\nSeverity\n: error\n\n\nExplanation\n: A plugin declaration file which is listed in your package.xml is missing from the package source folder.\n\n\n\n\nfirst_cmd\n() is called before \nsecond_cmd\n()\n\n\n\n\nID\n: order_violation\n\n\nSeverity\n: error\n\n\nExplanation\n: Certain configuration macros must be called in a specific order as specified by the catkin build manual. Failure to do so may lead to improper configuration of the package and build problems.\n\n\n\n\nold_cmd\n() is deprecated, use \nnew_cmd\n() instead\n\n\n\n\nID\n: deprecated_cmd\n\n\nSeverity\n: error\n\n\nExplanation\n: Some macros have been deprecated and replaced by newer versions. Please upgrade your CMakeLists.txt to ensure compatibility with future caktin versions.\n\n\n\n\nwrong_type\n_depend '\npkg\n' should be a \nright_type\n_depend\n\n\n\n\nID\n: wrong_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: You have listed a package as the wrong dependency type. The catkin build system defines a number of different dependencies for building a package, running its nodes or linking against its libraries. As a general rule, buildtool_depends are needed to build the package, build_depends are non-transitive build dependencies which are not visible to users of your package, build_export_depends are publicly visible transitive dependencies, exec_depends are needed at runtime, and test_depends are for unit tests only.\n\n\n\n\nCMake module '\nold_module\n' is deprecated, use '\nnew_module\n' instead\n\n\n\n\nID\n: deprecated_cmake_module\n\n\nSeverity\n: warning\n\n\nExplanation\n: Some CMake modules have been provided by cmake_modules in the past, but are now provided by the system package or CMake itself. Please upgrade your CMakeLists.txt to ensure compatibility with future catkin versions.\n\n\n\n\nOS error: \nmsg\n\n\n\n\nID\n: os_error\n\n\nSeverity\n: error\n\n\nExplanation\n: An operating system error has occured. This is not a linting problem per se but might be caused by a missing or unreadable file.\n\n\n\n\ncall to find_package(\npkg\n) shadows previously selected components\n\n\n\n\nID\n: shadowed_find\n\n\nSeverity\n: error\n\n\nExplanation\n: You have more than one \nfind_package()\n call for a package, and the COMPONENTS list of the later call does not include a previously chosen component.\n\n\n\n\ncatkin_metapackage() in regular package\n\n\n\n\nID\n: wrong_catkin_metapackage\n\n\nSeverity\n: error\n\n\nExplanation\n: The \ncatkin_metapackage()\n command signals your intent to declare a meta package, but the package.xml does not contain a \n tag.\n\n\n\n\ncatkin_package() dependency '\npkg\n' belongs in CATKIN_DEPENDS\n\n\n\n\nID\n: catkin_as_system_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: In your \ncatkin_package()\n call, you have listed a catkin package in the DEPENDS stanza, but it belongs in the CATKIN_DEPENDS stanza instead.\n\n\n\n\ncatkin_package() dependency '\npkg\n' belongs in DEPENDS\n\n\n\n\nID\n: system_as_catkin_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: In your \ncatkin_package()\n call, you have listed a system dependency in the CATKIN_DEPENDS stanza, but it belongs in the DEPENDS stanza instead.\n\n\n\n\ncatkin_package() dependency '\npkg\n' is not configured properly\n\n\n\n\nID\n: unconfigured_system_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: In order to export a system package as dependency, you must either call \nfind_package(\npkg\n)\n first or initialize the \npkg\n_INCLUDE_DIRS and \npkg\n_LIBRARIES variables manually.\n\n\n\n\ncatkin_package() exports non-package include path\n\n\n\n\nID\n: external_include_path\n\n\nSeverity\n: error\n\n\nExplanation\n: You listed one or more include paths in the INCLUDE_DIRS stanza of your \ncatkin_package()\n call which are not part of your package. If you want to export include paths of other modules, use \nfind_package()\n, \nfind_path()\n, and/or \nfind_library()\n and add the dependency to the DEPENDS stanza.\n\n\n\n\ncatkin_package() exports package include path that is not installed\n\n\n\n\nID\n: uninstalled_include_path\n\n\nSeverity\n: error, warning\n\n\nExplanation\n: Your package can be used from the devel space but cannot be installed properly, because the header files will not be copied to the proper location.\n\n\n\n\ncatkin_package() exports pkg-config module '\npkg\n'\n\n\n\n\nID\n: exported_pkg_config\n\n\nSeverity\n: error\n\n\nExplanation\n: Although CMake can invoke pkg-config to detect other modules, this does not work well with catkin, as pkg-config may require you to add link directories. Use the results of \npkg_check_module()\n as hint for \nfind_path()\n and \nfind_library()\n instead.\n\n\n\n\ncatkin_package() in meta package\n\n\n\n\nID\n: wrong_catkin_package\n\n\nSeverity\n: error\n\n\nExplanation\n: Meta packages use the \ncatkin_metapackage()\n command to declare a meta package. This performs additional checks and ensures that all requirements are met.\n\n\n\n\ncondition '\ncond\n' is ambiguous\n\n\n\n\nID\n: ambiguous_condition\n\n\nSeverity\n: warning\n\n\nExplanation\n: Historically, the \nif()\n command will interpret a single token as a variable name and transparently resolve it if possible. Unquoted variable references like \nif(${var})\n can lead to incorrect results if ${var} resolves to a different variable name. Use \nif(var)\n or \nif(\"${var}\")\n instead.\n\n\n\n\nduplicate \ncmd\n()\n\n\n\n\nID\n: duplicate_cmd\n\n\nSeverity\n: error\n\n\nExplanation\n: You have called this command more than once, but this does not make sense. If the calls use different arguments, consolidate them into a single call, otherwise simply remove the second.\n\n\n\n\nduplicate find_package(\npkg\n)\n\n\n\n\nID\n: duplicate_find\n\n\nSeverity\n: warning\n\n\nExplanation\n: You called \nfind_package()\n more than once for a particular package, which is not needed except for very specific, advanced circumstances.\n\n\n\n\nduplicate include path ${\npkg\n_INCLUDE_DIRS}\n\n\n\n\nID\n: duplicate_include_path\n\n\nSeverity\n: warning\n\n\nExplanation\n: Include paths of packages listed in the \nfind_package(catkin)\n command are added implicitly by the ${catkin_INCLUDE_DIRS} variable. There is no need to add it a second time.\n\n\n\n\nenvironment variables should not be used\n\n\n\n\nID\n: env_var\n\n\nSeverity\n: warning\n\n\nExplanation\n: The behavior of your build should not depend on any environment variables.\n\n\n\n\nexecutable file is not installed to bin destination\n\n\n\n\nID\n: wrong_bin_install_destination\n\n\nSeverity\n: warning\n\n\nExplanation\n: Your package installs one or more files to an unexpected location. Executable files should end up in either ${CATKIN_GLOBAL_BIN_DESTINATION} or ${CATKIN_PACKAGE_BIN_DESTINATION}.\n\n\n\n\nexported include path '\npath\n' does not exist\n\n\n\n\nID\n: missing_include_path\n\n\nSeverity\n: error\n\n\nExplanation\n: You have listed an invalid include path in the INCLUDE_DIRS stanza of the \ncatkin_package()\n command.\n\n\n\n\nexported library '\ntarget\n' cannot have different output name\n\n\n\n\nID\n: export_lib_renamed\n\n\nSeverity\n: error\n\n\nExplanation\n: Due to a limitation of the catkin build system, the \ncatkin_package()\n library export function will break if the logical target name is not equal to the actual library name.\n\n\n\n\nexported library '\ntarget\n' is not a library\n\n\n\n\nID\n: export_lib_not_lib\n\n\nSeverity\n: error\n\n\nExplanation\n: You listed a library in the LIBRARIES stanza of your \ncatkin_package()\n call, but it really is an executable.\n\n\n\n\nexported library '\ntarget\n' is not installed\n\n\n\n\nID\n: uninstalled_export_lib\n\n\nSeverity\n: error, warning\n\n\nExplanation\n: Your package can be used from the devel space but cannot be installed properly, because a library that is exported via \ncatkin_package()\n will not be copied to the proper location.\n\n\n\n\nexported package include path but no exported library\n\n\n\n\nID\n: missing_export_lib\n\n\nSeverity\n: warning\n\n\nExplanation\n: Your package exports a package include path and builds at least one library, which suggests that you may want to export the library to other packages as well.\n\n\n\n\nextra arguments in \ncmd\n()\n\n\n\n\nID\n: endblock_args\n\n\nSeverity\n: notice\n\n\nExplanation\n: The catkin manual recommends that \ncmd\n and other end-of-block statements have no arguments. If you have nested blocks, you should indent them properly instead.\n\n\n\n\nfile '\nscript\n' is executable but not installed\n\n\n\n\nID\n: uninstalled_script\n\n\nSeverity\n: warning\n\n\nExplanation\n: Your package contains a file that is marked as executable but not installed. If it is a script intended to be run (e.g. with rosrun), it will not work outside the devel tree. If it is not an executable script, you should fix the file permissions.\n\n\n\n\nfile setup.py found but no catkin_python_setup() call\n\n\n\n\nID\n: missing_python_setup\n\n\nSeverity\n: error\n\n\nExplanation\n: The \ncatkin_python_setup()\n call is required to properly configure python modules, and the existing setup.py indicates that your package provides one or more python modules.\n\n\n\n\nfind_package(\npkg\n) before find_package(cmake_modules)\n\n\n\n\nID\n: missing_cmake_modules\n\n\nSeverity\n: warning\n\n\nExplanation\n: You need to \nfind_package()\n cmake_modules before you can use one of its custom configuration modules.\n\n\n\n\nfind_package(\npkg\n) has no REQUIRED option\n\n\n\n\nID\n: missing_required\n\n\nSeverity\n: error, warning\n\n\nExplanation\n: The package cannot build without this dependency, so it should be marked as REQUIRED accordingly. Use \nif(\npkg\n_FOUND)\n clauses to use optional packages.\n\n\n\n\ngenerate_messages() called but no message declared\n\n\n\n\nID\n: unused_generate_msg\n\n\nSeverity\n: warning\n\n\nExplanation\n: The \ngenerate_messages()\n call creates the messages, services, and actions which are declared in your package. If your package does not supply any of these, you do not have to call \ngenerate_messages()\n at all.\n\n\n\n\nglobal variable '\nvar\n' should contain project name\n\n\n\n\nID\n: global_var_collision\n\n\nSeverity\n: notice\n\n\nExplanation\n: Global variables and options are stored in the cache. You should prefix your variable names with the project name to avoid name collisions with other packages.\n\n\n\n\ninclude path '\npath\n' is exported but not used for the build\n\n\n\n\nID\n: unused_include_path\n\n\nSeverity\n: warning\n\n\nExplanation\n: You have listed an include path in the INCLUDE_DIRS stanza of the \ncatkin_package()\n command, but that path is not mentioned in any \ninclude_directories()\n call.\n\n\n\n\ninclude paths '\npath\n' and '\nparent_path\n' are ambiguous\n\n\n\n\nID\n: ambiguous_include_path\n\n\nSeverity\n: warning\n\n\nExplanation\n: You have used two include paths where one is a parent of the other. Thus the same headers can be included with two different include paths which may confuse users. It is recommended that you keep your include paths consistent.\n\n\n\n\ninstall(\ntype\n ... \ndest\n) does not install to ${CATKIN_INSTALL_PREFIX}\n\n\n\n\nID\n: wrong_install_destination\n\n\nSeverity\n: warning\n\n\nExplanation\n: Your package installs one or more files to an unexpected location. Catkin provides a number of standard variables ${CATKIN_*_DESTINATION} to specify installation folders. You should use those to ensure that your package will continue to work if the file system layout is changed in the future.\n\n\n\n\nlaunch configuration needs \ntype\n_depend on '\npkg\n'\n\n\n\n\nID\n: launch_depend\n\n\nSeverity\n: warning\n\n\nExplanation\n: Your package refers to another package in one of its launch files, but you do not have this dependency in your package.xml\n\n\n\n\nlibrary output name '\noutput\n' has redundant 'lib' prefix\n\n\n\n\nID\n: redundant_lib_prefix\n\n\nSeverity\n: notice\n\n\nExplanation\n: Libraries are automatically prefixed with 'lib', so your library will end up with a file name like 'lib\noutput\n.so'. You can use \nset_target_properties(... PROPERTIES OUTPUT_NAME ...)\n to give your library a different file name without changing the target name.\n\n\n\n\nline is not indented properly\n\n\n\n\nID\n: indentation\n\n\nSeverity\n: notice\n\n\nExplanation\n: For better readability, each command should be placed on its own line. \nif()\n and \nforeach()\n bodies should be indented by one or more extra spaces.\n\n\n\n\nlink_directories() must not be used for system depends\n\n\n\n\nID\n: external_link_directory\n\n\nSeverity\n: error\n\n\nExplanation\n: Directories which are added to the search path with \nlink_directories()\n will not be propagated to dependent packages. Use \nfind_package()\n or \nfind_library()\n with the appropriate PATHS or HINTS instead.\n\n\n\n\nlist \nname\n should be sorted\n\n\n\n\nID\n: unsorted_list\n\n\nSeverity\n: notice\n\n\nExplanation\n: The catkin manual recommends that list element be kept in order.\n\n\n\n\nmalformed argument list: \nmsg\n\n\n\n\nID\n: argument_error\n\n\nSeverity\n: warning\n\n\nExplanation\n: You invoked a CMake command with a malformed argument list. Most likely, you forgot to properly quote variables which may be empty or undefined.\n\n\n\n\nmeaningless package description '\ntext\n'\n\n\n\n\nID\n: description_meaningless\n\n\nSeverity\n: notice\n\n\nExplanation\n: Your package description merely consists of typical filler words which do not actually describe the contents of your package in a meaningful way.\n\n\n\n\nmeta packages must not have \ntype\n_depends\n\n\n\n\nID\n: invalid_meta_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: Meta packages do not contain code or data and are merely dependency lists. As meta packages do neither build nor test anything, the only valid dependency type is the run_depend.\n\n\n\n\nmisconfigured catkin package '\npkg\n'\n\n\n\n\nID\n: misconfigured_catkin_package\n\n\nSeverity\n: error\n\n\nExplanation\n: You use an unsupported way to include a catkin package in your build. Even though this might work in your particular case, you should use the proper \nfind_package()\n mechanism to make sure that all relevant CMake macros will be run.\n\n\n\n\nmissing \ncmd\n()\n\n\n\n\nID\n: missing_cmd\n\n\nSeverity\n: error\n\n\nExplanation\n: You failed to call a command that is required for your package to work. Please refer to the catkin build manual for details.\n\n\n\n\nmissing \ntype\n_depend on '\npkg\n'\n\n\n\n\nID\n: missing_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: Your package uses features of another package but you failed to list this dependency in your package.xml\n\n\n\n\nmissing COMPONENTS keyword before '\npkg\n'\n\n\n\n\nID\n: missing_components\n\n\nSeverity\n: notice\n\n\nExplanation\n: The \nfind_package(catkin)\n call can add other catkin packages as dependencies with the COMPONENTS keyword. The \nfind_package()\n command lists additional packages but has no COMPONENTS keyword.\n\n\n\n\nmissing find_package(\npkg\n)\n\n\n\n\nID\n: missing_find\n\n\nSeverity\n: error\n\n\nExplanation\n: You failed to call \nfind_package()\n for a dependency of your package.\n\n\n\n\nmissing generate_messages()\n\n\n\n\nID\n: missing_generate_msg\n\n\nSeverity\n: error\n\n\nExplanation\n: The \ngenerate_messages()\n call creates the messages, services, and actions which are declared in your package by \nadd_message_files()\n, \nadd_service_files()\n, and \nadd_action_files()\n respectively.\n\n\n\n\nmissing include_directories(${catkin_INCLUDE_DIRS})\n\n\n\n\nID\n: unused_catkin_include_dirs\n\n\nSeverity\n: error\n\n\nExplanation\n: You must add the catkin include paths to your include search list, or you might experience build failures.\n\n\n\n\noperands for operator \nop\n should be quoted strings\n\n\n\n\nID\n: unquoted_string_op\n\n\nSeverity\n: notice\n\n\nExplanation\n: The catkin manual recommends that \nif()\n conditions with string operators should have the operands enclosed in double quotes.\n\n\n\n\npackage '\npkg\n' must be in CATKIN_DEPENDS in catkin_package()\n\n\n\n\nID\n: missing_catkin_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: You have a runtime dependency that you must add to the CATKIN_DEPENDS stanza of your \ncatkin_package()\n.\n\n\n\n\npackage description starts with boilerplate '\ntext\n'\n\n\n\n\nID\n: description_boilerplate\n\n\nSeverity\n: notice\n\n\nExplanation\n: Your package description starts with a number of typical filler words which do not actually describe the contents of your package. Typically, you can simply delete these words from the description, and it will still make sense and be much more concise.\n\n\n\n\npackage exports \nexport\n plugin but does not \ntype\n_depend on '\npkg\n'\n\n\n\n\nID\n: plugin_depend\n\n\nSeverity\n: warning\n\n\nExplanation\n: Your package exports a plugin for another package, but fails to list said package as a dependency.\n\n\n\n\npackage path name '\npath\n' differs from package name\n\n\n\n\nID\n: package_path_name\n\n\nSeverity\n: notice\n\n\nExplanation\n: Your package resides in a folder that has a different name than the package itself. This is confusing and might break the assumptions of some tools.\n\n\n\n\nparse error: \nmsg\n\n\n\n\nID\n: parse_error\n\n\nSeverity\n: warning\n\n\nExplanation\n: Your package has a malformed file that could not be processed for linting.\n\n\n\n\nproject name '\nname\n' differs from package name\n\n\n\n\nID\n: project_name\n\n\nSeverity\n: error\n\n\nExplanation\n: The CMake project name must be identical to the package name. For backwards compatibility reasons, both names should also be identical to the name of the source folder that contains the package.\n\n\n\n\nreferenced target '\ntarget\n' is not defined\n\n\n\n\nID\n: undefined_target\n\n\nSeverity\n: error\n\n\nExplanation\n: Your package installs or exports a CMake target which is not defined at all. This could be a typo, or the target is implicitly defined by a macro that is unknown to \ncatkin_lint\n.\n\n\n\n\nscript '\nfile\n' has no \ninterpreter\n shebang line\n\n\n\n\nID\n: missing_shebang\n\n\nSeverity\n: error\n\n\nExplanation\n: All \ninterpreter\n scripts need an appropriate shebang line, i.e. the first line has to start with '#!' and needs to name the full path to the \ninterpreter\n executable.\n\n\n\n\nscript '\nscript\n' must be executable\n\n\n\n\nID\n: script_not_executable\n\n\nSeverity\n: error\n\n\nExplanation\n: Your package contains a script file that has to be marked as executable. On Un*x systems, run 'chmod +x \"\nscript\n\"' to set the executable bit.\n\n\n\n\nsubdirectory '\nsubdir\n' contains a subproject\n\n\n\n\nID\n: subproject\n\n\nSeverity\n: warning\n\n\nExplanation\n: Your package has an independent subproject. This can interact with catkin in unusual ways and is strongly discouraged. No further checks are performed in this subdirectory.\n\n\n\n\nsubdirectory '\nsubdir\n' is added a second time\n\n\n\n\nID\n: duplicate_subdir\n\n\nSeverity\n: error\n\n\nExplanation\n: You added another subdirectory with \nadd_subdirectory()\n multiple times. This can also happen if you accidentally created a loop where subdir A adds subdir B, which adds subdir A again.\n\n\n\n\nsubdirectory '\nsubdir\n' is missing\n\n\n\n\nID\n: missing_subdir\n\n\nSeverity\n: error\n\n\nExplanation\n: You specified a subdirectory which does not exists or is unreadable.\n\n\n\n\nsubdirectory \nsubdir\n is not in package\n\n\n\n\nID\n: external_subdir\n\n\nSeverity\n: error\n\n\nExplanation\n: You added another subdirectory with \nadd_subdirectory()\n, but the specified path points outside of the package source directory.\n\n\n\n\ntarget '\nexport_target\n' depends on target '\ntarget\n' which is not installed\n\n\n\n\nID\n: uninstalled_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: Your package can be used from the devel space but cannot be installed properly, because one of your installed targets depends on a library from your package that is not installed as well.\n\n\n\n\ntarget '\ntarget\n' has invalid characters in its output file name\n\n\n\n\nID\n: invalid_target_output\n\n\nSeverity\n: error\n\n\nExplanation\n: The output file that your target is supposed to generate contains invalid characters in its name. You probably forget to call \nset_target_properties(... PROPERTIES OUTPUT_NAME ...)\n\n\n\n\ntarget '\ntarget\n' is not installed\n\n\n\n\nID\n: uninstalled_target\n\n\nSeverity\n: warning\n\n\nExplanation\n: Your package can be used from the devel space but cannot be installed properly, because the build target will not be copied to the proper location.\n\n\n\n\ntest_depend '\npkg\n' used without if(CATKIN_ENABLE_TESTING)\n\n\n\n\nID\n: unguarded_test_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: You have used a test dependency without properly guarding it by a \nif(CATKIN_ENABLE_TESTING)\n block. You must add a proper build dependency if you wish to use this package even if tests are disabled.\n\n\n\n\nunconfigured build_depend on '\npkg\n'\n\n\n\n\nID\n: unconfigured_build_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: You declare a build dependency on another package but neither call \nfind_package()\n nor have it listed as catkin component in the \nfind_package(catkin)\n call.\n\n\n\n\nunconfigured message dependency '\npkg\n'\n\n\n\n\nID\n: unconfigured_msg_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: Your messages depend on another package which is neither \nfind_package()\n'd nor listed as a component in the \nfind_package(catkin)\n call.\n\n\n\n\nunknown package '\npkg\n'\n\n\n\n\nID\n: unknown_package\n\n\nSeverity\n: error\n\n\nExplanation\n: You are referring to a package which seems to be neither a catkin package nor a known system dependency. You may have misspelled the name, or your rosdep database needs to be refreshed with \"rosdep update\".\n\n\n\n\nunused \ntype\n_depend on '\npkg\n'\n\n\n\n\nID\n: unused_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: You have a listed a package dependency but do not appear to use any of the features it provides.\n\n\n\n\nuse ${PROJECT_NAME} instead of '\nname\n'\n\n\n\n\nID\n: literal_project_name\n\n\nSeverity\n: notice\n\n\nExplanation\n: The catkin manual recommends that you use the ${PROJECT_NAME} variable instead of the literal project name.\n\n\n\n\nuse find_package(\npkg\n) instead of include(Find\npkg\n.cmake)\n\n\n\n\nID\n: find_by_include\n\n\nSeverity\n: error\n\n\nExplanation\n: The FindXXX.cmake modules are intended to be included by the \nfind_package()\n command.\n\n\n\n\nuse of link_directories() is strongly discouraged\n\n\n\n\nID\n: link_directory\n\n\nSeverity\n: warning\n\n\nExplanation\n: Directories which are added to the search path with \nlink_directories()\n will not be propagated to dependent packages. You should avoid this command or at least be aware that it might not work as expected in dependent packages.\n\n\n\n\nvariable \nvar\n is modified\n\n\n\n\nID\n: critical_var_append\n\n\nSeverity\n: warning\n\n\nExplanation\n: You have appended extra data to a critical CMake variable. This might break the build on different systems or affect the global catkin workspace in unintended ways.\n\n\n\n\nvariable \nvar\n is modified\n\n\n\n\nID\n: immutable_var\n\n\nSeverity\n: error\n\n\nExplanation\n: You have modified a CMake variable that is initialized by CMake itself and must not be modified under any circumstances.\n\n\n\n\nvariable \nvar\n is overwritten\n\n\n\n\nID\n: critical_var_overwrite\n\n\nSeverity\n: error\n\n\nExplanation\n: You have overwritten a critical CMake variable and its original content is lost. This will most likely break the build on different systems or affect the global catkin workspace in unintended ways.\n\n\n\n\nvariable CMAKE_BUILD_TYPE is overwritten unconditionally\n\n\n\n\nID\n: cmake_build_type\n\n\nSeverity\n: error\n\n\nExplanation\n: If you wish to provide a default value for CMAKE_BUILD_TYPE, make sure that you do not overwrite user preferences. You should guard the \nset()\n command with an appropriate \nif(NOT CMAKE_BUILD_TYPE)\n block.",
            "title": "Messages"
        },
        {
            "location": "/messages/#catkin_lint-diagnostic-messages",
            "text": "This is a list of all messages which might be shown by  catkin_lint .\nEach diagnostic has a unique ID (such as  catkin_order_violation ),\nwhich you can use to disable certain messages, either with the command line option --ignore ID , or by adding a pragma line  #catkin_lint: ignore ID  at the beginning\nof the CMakeLists.txt file. As a third option, you can add a pragma line  #catkin_lint: ignore_once ID \nright before the offending statement. Use this if you want to ignore a particular instance\nof a problem but still be notified if the same problem occurs someplace else. You may\nalso use  #catkin_lint: report ID  at any point to override a previous  ignore .  Since version 1.5.4, you may also customize the severity with the command line options --error ID ,  --warning ID , or  --notice ID . You can also add the pragma line #catkin_lint: skip  in any  if() ,  foreach() , or  macro()  block, which will instruct\nthe parser to ignore all remaining commands in the block until the  else() ,  endif() , endforeach() , or  endmacro()  statement.",
            "title": "catkin_lint diagnostic messages"
        },
        {
            "location": "/messages/#pkg-in-find_packagecatkin-is-not-a-catkin-package",
            "text": "ID : no_catkin_component  Severity : error  Explanation : The  find_package(catkin)  call can list other catkin packages as dependencies with the COMPONENTS keyword. This is shorter than multiple  find_package()  calls, but does not work for system dependencies.",
            "title": "'pkg' in find_package(catkin) is not a catkin package"
        },
        {
            "location": "/messages/#cmd-exports-external-scope-path-directory",
            "text": "ID : external_interface_path  Severity : warning  Explanation : You have exported an include path as part of your interface for dependent targets, but that path does not belong to your package. You probably meant to use the PRIVATE scope if you merely need that include path for your build. If you actually wanted to export the path to your dependees, you hould be aware that target properties will be exported as fixed strings, meaning your installed package will break if that location changes for any reason. A more robust way would be to use  target_link_libraries( scope )  with the proper imported target instead.",
            "title": "cmd() exports external scope path 'directory'"
        },
        {
            "location": "/messages/#cmd-is-called-before-find_packagecatkin",
            "text": "ID : catkin_order_violation  Severity : error  Explanation : Catkin macros cannot be called before catkin has been configured with  find_package(catkin) .",
            "title": "cmd() is called before find_package(catkin)"
        },
        {
            "location": "/messages/#cmd-is-not-allowed-in-meta-packages",
            "text": "ID : invalid_meta_command  Severity : error  Explanation : Meta packages do not contain code or data and are merely dependency lists with very strict requirements for the format of the CMakeLists.txt file.",
            "title": "cmd() is not allowed in meta packages"
        },
        {
            "location": "/messages/#cmd-needs-missing-directory-directory",
            "text": "ID : missing_directory  Severity : error  Explanation : This catkin command processes a particular directory which is missing from the package source folder.",
            "title": "cmd() needs missing directory 'directory'"
        },
        {
            "location": "/messages/#cmd-needs-missing-file-file",
            "text": "ID : missing_file  Severity : error  Explanation : This catkin command processes a particular file which is missing from the package source folder.",
            "title": "cmd() needs missing file 'file'"
        },
        {
            "location": "/messages/#cmd-should-be-all-lower-case",
            "text": "ID : cmd_case  Severity : notice  Explanation : The catkin manual recommends that all commands be written in lower case.",
            "title": "cmd() should be all lower-case"
        },
        {
            "location": "/messages/#cmd-used-without-ifcatkin_enable_testing",
            "text": "ID : unguarded_test_cmd  Severity : error  Explanation : You have used a test command without properly guarding it by a  if(CATKIN_ENABLE_TESTING)  block.",
            "title": "cmd() used without if(CATKIN_ENABLE_TESTING)"
        },
        {
            "location": "/messages/#cmd-uses-directory-directory-which-is-not-in-package",
            "text": "ID : external_directory  Severity : warning  Explanation : This catkin command uses a directory which lies outside of the package source folder. While this may work in your particular setup, you cannot assume file locations in general. Use  find_path()  to detect external locations insteed.",
            "title": "cmd() uses directory 'directory' which is not in package"
        },
        {
            "location": "/messages/#cmd-uses-file-file-which-is-not-in-package",
            "text": "ID : external_file  Severity : error, warning  Explanation : This catkin command uses a file which lies outside of the package source folder. While this may work in your particular setup, you cannot assume file locations in general. Use  find_file()  to detect external locations insteed.",
            "title": "cmd() uses file 'file' which is not in package"
        },
        {
            "location": "/messages/#export-plugin-file-file-is-not-installed-to-catkin_package_share_destination",
            "text": "ID : uninstalled_plugin  Severity : error, warning  Explanation : Your package can be used from the devel space but cannot be installed properly, because a plugin declaration file which is listed in your package.xml is not installed to the correct location.",
            "title": "export plugin file 'file' is not installed to ${CATKIN_PACKAGE_SHARE_DESTINATION}"
        },
        {
            "location": "/messages/#export-plugin-file-reference-must-start-with-prefix",
            "text": "ID : plugin_export_prefix  Severity : error  Explanation : The ${prefix} variable is carefully overloaded to work with both devel space and install space and must be used in all   tags.",
            "title": "export plugin file reference must start with '${prefix}/'"
        },
        {
            "location": "/messages/#export-plugin-refers-to-missing-file-file",
            "text": "ID : missing_plugin  Severity : error  Explanation : A plugin declaration file which is listed in your package.xml is missing from the package source folder.",
            "title": "export plugin refers to missing file 'file'"
        },
        {
            "location": "/messages/#first_cmd-is-called-before-second_cmd",
            "text": "ID : order_violation  Severity : error  Explanation : Certain configuration macros must be called in a specific order as specified by the catkin build manual. Failure to do so may lead to improper configuration of the package and build problems.",
            "title": "first_cmd() is called before second_cmd()"
        },
        {
            "location": "/messages/#old_cmd-is-deprecated-use-new_cmd-instead",
            "text": "ID : deprecated_cmd  Severity : error  Explanation : Some macros have been deprecated and replaced by newer versions. Please upgrade your CMakeLists.txt to ensure compatibility with future caktin versions.",
            "title": "old_cmd() is deprecated, use new_cmd() instead"
        },
        {
            "location": "/messages/#wrong_type_depend-pkg-should-be-a-right_type_depend",
            "text": "ID : wrong_depend  Severity : error  Explanation : You have listed a package as the wrong dependency type. The catkin build system defines a number of different dependencies for building a package, running its nodes or linking against its libraries. As a general rule, buildtool_depends are needed to build the package, build_depends are non-transitive build dependencies which are not visible to users of your package, build_export_depends are publicly visible transitive dependencies, exec_depends are needed at runtime, and test_depends are for unit tests only.",
            "title": "wrong_type_depend 'pkg' should be a right_type_depend"
        },
        {
            "location": "/messages/#cmake-module-old_module-is-deprecated-use-new_module-instead",
            "text": "ID : deprecated_cmake_module  Severity : warning  Explanation : Some CMake modules have been provided by cmake_modules in the past, but are now provided by the system package or CMake itself. Please upgrade your CMakeLists.txt to ensure compatibility with future catkin versions.",
            "title": "CMake module 'old_module' is deprecated, use 'new_module' instead"
        },
        {
            "location": "/messages/#os-error-msg",
            "text": "ID : os_error  Severity : error  Explanation : An operating system error has occured. This is not a linting problem per se but might be caused by a missing or unreadable file.",
            "title": "OS error: msg"
        },
        {
            "location": "/messages/#call-to-find_packagepkg-shadows-previously-selected-components",
            "text": "ID : shadowed_find  Severity : error  Explanation : You have more than one  find_package()  call for a package, and the COMPONENTS list of the later call does not include a previously chosen component.",
            "title": "call to find_package(pkg) shadows previously selected components"
        },
        {
            "location": "/messages/#catkin_metapackage-in-regular-package",
            "text": "ID : wrong_catkin_metapackage  Severity : error  Explanation : The  catkin_metapackage()  command signals your intent to declare a meta package, but the package.xml does not contain a   tag.",
            "title": "catkin_metapackage() in regular package"
        },
        {
            "location": "/messages/#catkin_package-dependency-pkg-belongs-in-catkin_depends",
            "text": "ID : catkin_as_system_depend  Severity : error  Explanation : In your  catkin_package()  call, you have listed a catkin package in the DEPENDS stanza, but it belongs in the CATKIN_DEPENDS stanza instead.",
            "title": "catkin_package() dependency 'pkg' belongs in CATKIN_DEPENDS"
        },
        {
            "location": "/messages/#catkin_package-dependency-pkg-belongs-in-depends",
            "text": "ID : system_as_catkin_depend  Severity : error  Explanation : In your  catkin_package()  call, you have listed a system dependency in the CATKIN_DEPENDS stanza, but it belongs in the DEPENDS stanza instead.",
            "title": "catkin_package() dependency 'pkg' belongs in DEPENDS"
        },
        {
            "location": "/messages/#catkin_package-dependency-pkg-is-not-configured-properly",
            "text": "ID : unconfigured_system_depend  Severity : error  Explanation : In order to export a system package as dependency, you must either call  find_package( pkg )  first or initialize the  pkg _INCLUDE_DIRS and  pkg _LIBRARIES variables manually.",
            "title": "catkin_package() dependency 'pkg' is not configured properly"
        },
        {
            "location": "/messages/#catkin_package-exports-non-package-include-path",
            "text": "ID : external_include_path  Severity : error  Explanation : You listed one or more include paths in the INCLUDE_DIRS stanza of your  catkin_package()  call which are not part of your package. If you want to export include paths of other modules, use  find_package() ,  find_path() , and/or  find_library()  and add the dependency to the DEPENDS stanza.",
            "title": "catkin_package() exports non-package include path"
        },
        {
            "location": "/messages/#catkin_package-exports-package-include-path-that-is-not-installed",
            "text": "ID : uninstalled_include_path  Severity : error, warning  Explanation : Your package can be used from the devel space but cannot be installed properly, because the header files will not be copied to the proper location.",
            "title": "catkin_package() exports package include path that is not installed"
        },
        {
            "location": "/messages/#catkin_package-exports-pkg-config-module-pkg",
            "text": "ID : exported_pkg_config  Severity : error  Explanation : Although CMake can invoke pkg-config to detect other modules, this does not work well with catkin, as pkg-config may require you to add link directories. Use the results of  pkg_check_module()  as hint for  find_path()  and  find_library()  instead.",
            "title": "catkin_package() exports pkg-config module 'pkg'"
        },
        {
            "location": "/messages/#catkin_package-in-meta-package",
            "text": "ID : wrong_catkin_package  Severity : error  Explanation : Meta packages use the  catkin_metapackage()  command to declare a meta package. This performs additional checks and ensures that all requirements are met.",
            "title": "catkin_package() in meta package"
        },
        {
            "location": "/messages/#condition-cond-is-ambiguous",
            "text": "ID : ambiguous_condition  Severity : warning  Explanation : Historically, the  if()  command will interpret a single token as a variable name and transparently resolve it if possible. Unquoted variable references like  if(${var})  can lead to incorrect results if ${var} resolves to a different variable name. Use  if(var)  or  if(\"${var}\")  instead.",
            "title": "condition 'cond' is ambiguous"
        },
        {
            "location": "/messages/#duplicate-cmd",
            "text": "ID : duplicate_cmd  Severity : error  Explanation : You have called this command more than once, but this does not make sense. If the calls use different arguments, consolidate them into a single call, otherwise simply remove the second.",
            "title": "duplicate cmd()"
        },
        {
            "location": "/messages/#duplicate-find_packagepkg",
            "text": "ID : duplicate_find  Severity : warning  Explanation : You called  find_package()  more than once for a particular package, which is not needed except for very specific, advanced circumstances.",
            "title": "duplicate find_package(pkg)"
        },
        {
            "location": "/messages/#duplicate-include-path-pkg_include_dirs",
            "text": "ID : duplicate_include_path  Severity : warning  Explanation : Include paths of packages listed in the  find_package(catkin)  command are added implicitly by the ${catkin_INCLUDE_DIRS} variable. There is no need to add it a second time.",
            "title": "duplicate include path ${pkg_INCLUDE_DIRS}"
        },
        {
            "location": "/messages/#environment-variables-should-not-be-used",
            "text": "ID : env_var  Severity : warning  Explanation : The behavior of your build should not depend on any environment variables.",
            "title": "environment variables should not be used"
        },
        {
            "location": "/messages/#executable-file-is-not-installed-to-bin-destination",
            "text": "ID : wrong_bin_install_destination  Severity : warning  Explanation : Your package installs one or more files to an unexpected location. Executable files should end up in either ${CATKIN_GLOBAL_BIN_DESTINATION} or ${CATKIN_PACKAGE_BIN_DESTINATION}.",
            "title": "executable file is not installed to bin destination"
        },
        {
            "location": "/messages/#exported-include-path-path-does-not-exist",
            "text": "ID : missing_include_path  Severity : error  Explanation : You have listed an invalid include path in the INCLUDE_DIRS stanza of the  catkin_package()  command.",
            "title": "exported include path 'path' does not exist"
        },
        {
            "location": "/messages/#exported-library-target-cannot-have-different-output-name",
            "text": "ID : export_lib_renamed  Severity : error  Explanation : Due to a limitation of the catkin build system, the  catkin_package()  library export function will break if the logical target name is not equal to the actual library name.",
            "title": "exported library 'target' cannot have different output name"
        },
        {
            "location": "/messages/#exported-library-target-is-not-a-library",
            "text": "ID : export_lib_not_lib  Severity : error  Explanation : You listed a library in the LIBRARIES stanza of your  catkin_package()  call, but it really is an executable.",
            "title": "exported library 'target' is not a library"
        },
        {
            "location": "/messages/#exported-library-target-is-not-installed",
            "text": "ID : uninstalled_export_lib  Severity : error, warning  Explanation : Your package can be used from the devel space but cannot be installed properly, because a library that is exported via  catkin_package()  will not be copied to the proper location.",
            "title": "exported library 'target' is not installed"
        },
        {
            "location": "/messages/#exported-package-include-path-but-no-exported-library",
            "text": "ID : missing_export_lib  Severity : warning  Explanation : Your package exports a package include path and builds at least one library, which suggests that you may want to export the library to other packages as well.",
            "title": "exported package include path but no exported library"
        },
        {
            "location": "/messages/#extra-arguments-in-cmd",
            "text": "ID : endblock_args  Severity : notice  Explanation : The catkin manual recommends that  cmd  and other end-of-block statements have no arguments. If you have nested blocks, you should indent them properly instead.",
            "title": "extra arguments in cmd()"
        },
        {
            "location": "/messages/#file-script-is-executable-but-not-installed",
            "text": "ID : uninstalled_script  Severity : warning  Explanation : Your package contains a file that is marked as executable but not installed. If it is a script intended to be run (e.g. with rosrun), it will not work outside the devel tree. If it is not an executable script, you should fix the file permissions.",
            "title": "file 'script' is executable but not installed"
        },
        {
            "location": "/messages/#file-setuppy-found-but-no-catkin_python_setup-call",
            "text": "ID : missing_python_setup  Severity : error  Explanation : The  catkin_python_setup()  call is required to properly configure python modules, and the existing setup.py indicates that your package provides one or more python modules.",
            "title": "file setup.py found but no catkin_python_setup() call"
        },
        {
            "location": "/messages/#find_packagepkg-before-find_packagecmake_modules",
            "text": "ID : missing_cmake_modules  Severity : warning  Explanation : You need to  find_package()  cmake_modules before you can use one of its custom configuration modules.",
            "title": "find_package(pkg) before find_package(cmake_modules)"
        },
        {
            "location": "/messages/#find_packagepkg-has-no-required-option",
            "text": "ID : missing_required  Severity : error, warning  Explanation : The package cannot build without this dependency, so it should be marked as REQUIRED accordingly. Use  if( pkg _FOUND)  clauses to use optional packages.",
            "title": "find_package(pkg) has no REQUIRED option"
        },
        {
            "location": "/messages/#generate_messages-called-but-no-message-declared",
            "text": "ID : unused_generate_msg  Severity : warning  Explanation : The  generate_messages()  call creates the messages, services, and actions which are declared in your package. If your package does not supply any of these, you do not have to call  generate_messages()  at all.",
            "title": "generate_messages() called but no message declared"
        },
        {
            "location": "/messages/#global-variable-var-should-contain-project-name",
            "text": "ID : global_var_collision  Severity : notice  Explanation : Global variables and options are stored in the cache. You should prefix your variable names with the project name to avoid name collisions with other packages.",
            "title": "global variable 'var' should contain project name"
        },
        {
            "location": "/messages/#include-path-path-is-exported-but-not-used-for-the-build",
            "text": "ID : unused_include_path  Severity : warning  Explanation : You have listed an include path in the INCLUDE_DIRS stanza of the  catkin_package()  command, but that path is not mentioned in any  include_directories()  call.",
            "title": "include path 'path' is exported but not used for the build"
        },
        {
            "location": "/messages/#include-paths-path-and-parent_path-are-ambiguous",
            "text": "ID : ambiguous_include_path  Severity : warning  Explanation : You have used two include paths where one is a parent of the other. Thus the same headers can be included with two different include paths which may confuse users. It is recommended that you keep your include paths consistent.",
            "title": "include paths 'path' and 'parent_path' are ambiguous"
        },
        {
            "location": "/messages/#installtype-dest-does-not-install-to-catkin_install_prefix",
            "text": "ID : wrong_install_destination  Severity : warning  Explanation : Your package installs one or more files to an unexpected location. Catkin provides a number of standard variables ${CATKIN_*_DESTINATION} to specify installation folders. You should use those to ensure that your package will continue to work if the file system layout is changed in the future.",
            "title": "install(type ... dest) does not install to ${CATKIN_INSTALL_PREFIX}"
        },
        {
            "location": "/messages/#launch-configuration-needs-type_depend-on-pkg",
            "text": "ID : launch_depend  Severity : warning  Explanation : Your package refers to another package in one of its launch files, but you do not have this dependency in your package.xml",
            "title": "launch configuration needs type_depend on 'pkg'"
        },
        {
            "location": "/messages/#library-output-name-output-has-redundant-lib-prefix",
            "text": "ID : redundant_lib_prefix  Severity : notice  Explanation : Libraries are automatically prefixed with 'lib', so your library will end up with a file name like 'lib output .so'. You can use  set_target_properties(... PROPERTIES OUTPUT_NAME ...)  to give your library a different file name without changing the target name.",
            "title": "library output name 'output' has redundant 'lib' prefix"
        },
        {
            "location": "/messages/#line-is-not-indented-properly",
            "text": "ID : indentation  Severity : notice  Explanation : For better readability, each command should be placed on its own line.  if()  and  foreach()  bodies should be indented by one or more extra spaces.",
            "title": "line is not indented properly"
        },
        {
            "location": "/messages/#link_directories-must-not-be-used-for-system-depends",
            "text": "ID : external_link_directory  Severity : error  Explanation : Directories which are added to the search path with  link_directories()  will not be propagated to dependent packages. Use  find_package()  or  find_library()  with the appropriate PATHS or HINTS instead.",
            "title": "link_directories() must not be used for system depends"
        },
        {
            "location": "/messages/#list-name-should-be-sorted",
            "text": "ID : unsorted_list  Severity : notice  Explanation : The catkin manual recommends that list element be kept in order.",
            "title": "list name should be sorted"
        },
        {
            "location": "/messages/#malformed-argument-list-msg",
            "text": "ID : argument_error  Severity : warning  Explanation : You invoked a CMake command with a malformed argument list. Most likely, you forgot to properly quote variables which may be empty or undefined.",
            "title": "malformed argument list: msg"
        },
        {
            "location": "/messages/#meaningless-package-description-text",
            "text": "ID : description_meaningless  Severity : notice  Explanation : Your package description merely consists of typical filler words which do not actually describe the contents of your package in a meaningful way.",
            "title": "meaningless package description 'text'"
        },
        {
            "location": "/messages/#meta-packages-must-not-have-type_depends",
            "text": "ID : invalid_meta_depend  Severity : error  Explanation : Meta packages do not contain code or data and are merely dependency lists. As meta packages do neither build nor test anything, the only valid dependency type is the run_depend.",
            "title": "meta packages must not have type_depends"
        },
        {
            "location": "/messages/#misconfigured-catkin-package-pkg",
            "text": "ID : misconfigured_catkin_package  Severity : error  Explanation : You use an unsupported way to include a catkin package in your build. Even though this might work in your particular case, you should use the proper  find_package()  mechanism to make sure that all relevant CMake macros will be run.",
            "title": "misconfigured catkin package 'pkg'"
        },
        {
            "location": "/messages/#missing-cmd",
            "text": "ID : missing_cmd  Severity : error  Explanation : You failed to call a command that is required for your package to work. Please refer to the catkin build manual for details.",
            "title": "missing cmd()"
        },
        {
            "location": "/messages/#missing-type_depend-on-pkg",
            "text": "ID : missing_depend  Severity : error  Explanation : Your package uses features of another package but you failed to list this dependency in your package.xml",
            "title": "missing type_depend on 'pkg'"
        },
        {
            "location": "/messages/#missing-components-keyword-before-pkg",
            "text": "ID : missing_components  Severity : notice  Explanation : The  find_package(catkin)  call can add other catkin packages as dependencies with the COMPONENTS keyword. The  find_package()  command lists additional packages but has no COMPONENTS keyword.",
            "title": "missing COMPONENTS keyword before 'pkg'"
        },
        {
            "location": "/messages/#missing-find_packagepkg",
            "text": "ID : missing_find  Severity : error  Explanation : You failed to call  find_package()  for a dependency of your package.",
            "title": "missing find_package(pkg)"
        },
        {
            "location": "/messages/#missing-generate_messages",
            "text": "ID : missing_generate_msg  Severity : error  Explanation : The  generate_messages()  call creates the messages, services, and actions which are declared in your package by  add_message_files() ,  add_service_files() , and  add_action_files()  respectively.",
            "title": "missing generate_messages()"
        },
        {
            "location": "/messages/#missing-include_directoriescatkin_include_dirs",
            "text": "ID : unused_catkin_include_dirs  Severity : error  Explanation : You must add the catkin include paths to your include search list, or you might experience build failures.",
            "title": "missing include_directories(${catkin_INCLUDE_DIRS})"
        },
        {
            "location": "/messages/#operands-for-operator-op-should-be-quoted-strings",
            "text": "ID : unquoted_string_op  Severity : notice  Explanation : The catkin manual recommends that  if()  conditions with string operators should have the operands enclosed in double quotes.",
            "title": "operands for operator op should be quoted strings"
        },
        {
            "location": "/messages/#package-pkg-must-be-in-catkin_depends-in-catkin_package",
            "text": "ID : missing_catkin_depend  Severity : error  Explanation : You have a runtime dependency that you must add to the CATKIN_DEPENDS stanza of your  catkin_package() .",
            "title": "package 'pkg' must be in CATKIN_DEPENDS in catkin_package()"
        },
        {
            "location": "/messages/#package-description-starts-with-boilerplate-text",
            "text": "ID : description_boilerplate  Severity : notice  Explanation : Your package description starts with a number of typical filler words which do not actually describe the contents of your package. Typically, you can simply delete these words from the description, and it will still make sense and be much more concise.",
            "title": "package description starts with boilerplate 'text'"
        },
        {
            "location": "/messages/#package-exports-export-plugin-but-does-not-type_depend-on-pkg",
            "text": "ID : plugin_depend  Severity : warning  Explanation : Your package exports a plugin for another package, but fails to list said package as a dependency.",
            "title": "package exports export plugin but does not type_depend on 'pkg'"
        },
        {
            "location": "/messages/#package-path-name-path-differs-from-package-name",
            "text": "ID : package_path_name  Severity : notice  Explanation : Your package resides in a folder that has a different name than the package itself. This is confusing and might break the assumptions of some tools.",
            "title": "package path name 'path' differs from package name"
        },
        {
            "location": "/messages/#parse-error-msg",
            "text": "ID : parse_error  Severity : warning  Explanation : Your package has a malformed file that could not be processed for linting.",
            "title": "parse error: msg"
        },
        {
            "location": "/messages/#project-name-name-differs-from-package-name",
            "text": "ID : project_name  Severity : error  Explanation : The CMake project name must be identical to the package name. For backwards compatibility reasons, both names should also be identical to the name of the source folder that contains the package.",
            "title": "project name 'name' differs from package name"
        },
        {
            "location": "/messages/#referenced-target-target-is-not-defined",
            "text": "ID : undefined_target  Severity : error  Explanation : Your package installs or exports a CMake target which is not defined at all. This could be a typo, or the target is implicitly defined by a macro that is unknown to  catkin_lint .",
            "title": "referenced target 'target' is not defined"
        },
        {
            "location": "/messages/#script-file-has-no-interpreter-shebang-line",
            "text": "ID : missing_shebang  Severity : error  Explanation : All  interpreter  scripts need an appropriate shebang line, i.e. the first line has to start with '#!' and needs to name the full path to the  interpreter  executable.",
            "title": "script 'file' has no interpreter shebang line"
        },
        {
            "location": "/messages/#script-script-must-be-executable",
            "text": "ID : script_not_executable  Severity : error  Explanation : Your package contains a script file that has to be marked as executable. On Un*x systems, run 'chmod +x \" script \"' to set the executable bit.",
            "title": "script 'script' must be executable"
        },
        {
            "location": "/messages/#subdirectory-subdir-contains-a-subproject",
            "text": "ID : subproject  Severity : warning  Explanation : Your package has an independent subproject. This can interact with catkin in unusual ways and is strongly discouraged. No further checks are performed in this subdirectory.",
            "title": "subdirectory 'subdir' contains a subproject"
        },
        {
            "location": "/messages/#subdirectory-subdir-is-added-a-second-time",
            "text": "ID : duplicate_subdir  Severity : error  Explanation : You added another subdirectory with  add_subdirectory()  multiple times. This can also happen if you accidentally created a loop where subdir A adds subdir B, which adds subdir A again.",
            "title": "subdirectory 'subdir' is added a second time"
        },
        {
            "location": "/messages/#subdirectory-subdir-is-missing",
            "text": "ID : missing_subdir  Severity : error  Explanation : You specified a subdirectory which does not exists or is unreadable.",
            "title": "subdirectory 'subdir' is missing"
        },
        {
            "location": "/messages/#subdirectory-subdir-is-not-in-package",
            "text": "ID : external_subdir  Severity : error  Explanation : You added another subdirectory with  add_subdirectory() , but the specified path points outside of the package source directory.",
            "title": "subdirectory subdir is not in package"
        },
        {
            "location": "/messages/#target-export_target-depends-on-target-target-which-is-not-installed",
            "text": "ID : uninstalled_depend  Severity : error  Explanation : Your package can be used from the devel space but cannot be installed properly, because one of your installed targets depends on a library from your package that is not installed as well.",
            "title": "target 'export_target' depends on target 'target' which is not installed"
        },
        {
            "location": "/messages/#target-target-has-invalid-characters-in-its-output-file-name",
            "text": "ID : invalid_target_output  Severity : error  Explanation : The output file that your target is supposed to generate contains invalid characters in its name. You probably forget to call  set_target_properties(... PROPERTIES OUTPUT_NAME ...)",
            "title": "target 'target' has invalid characters in its output file name"
        },
        {
            "location": "/messages/#target-target-is-not-installed",
            "text": "ID : uninstalled_target  Severity : warning  Explanation : Your package can be used from the devel space but cannot be installed properly, because the build target will not be copied to the proper location.",
            "title": "target 'target' is not installed"
        },
        {
            "location": "/messages/#test_depend-pkg-used-without-ifcatkin_enable_testing",
            "text": "ID : unguarded_test_depend  Severity : error  Explanation : You have used a test dependency without properly guarding it by a  if(CATKIN_ENABLE_TESTING)  block. You must add a proper build dependency if you wish to use this package even if tests are disabled.",
            "title": "test_depend 'pkg' used without if(CATKIN_ENABLE_TESTING)"
        },
        {
            "location": "/messages/#unconfigured-build_depend-on-pkg",
            "text": "ID : unconfigured_build_depend  Severity : error  Explanation : You declare a build dependency on another package but neither call  find_package()  nor have it listed as catkin component in the  find_package(catkin)  call.",
            "title": "unconfigured build_depend on 'pkg'"
        },
        {
            "location": "/messages/#unconfigured-message-dependency-pkg",
            "text": "ID : unconfigured_msg_depend  Severity : error  Explanation : Your messages depend on another package which is neither  find_package() 'd nor listed as a component in the  find_package(catkin)  call.",
            "title": "unconfigured message dependency 'pkg'"
        },
        {
            "location": "/messages/#unknown-package-pkg",
            "text": "ID : unknown_package  Severity : error  Explanation : You are referring to a package which seems to be neither a catkin package nor a known system dependency. You may have misspelled the name, or your rosdep database needs to be refreshed with \"rosdep update\".",
            "title": "unknown package 'pkg'"
        },
        {
            "location": "/messages/#unused-type_depend-on-pkg",
            "text": "ID : unused_depend  Severity : error  Explanation : You have a listed a package dependency but do not appear to use any of the features it provides.",
            "title": "unused type_depend on 'pkg'"
        },
        {
            "location": "/messages/#use-project_name-instead-of-name",
            "text": "ID : literal_project_name  Severity : notice  Explanation : The catkin manual recommends that you use the ${PROJECT_NAME} variable instead of the literal project name.",
            "title": "use ${PROJECT_NAME} instead of 'name'"
        },
        {
            "location": "/messages/#use-find_packagepkg-instead-of-includefindpkgcmake",
            "text": "ID : find_by_include  Severity : error  Explanation : The FindXXX.cmake modules are intended to be included by the  find_package()  command.",
            "title": "use find_package(pkg) instead of include(Findpkg.cmake)"
        },
        {
            "location": "/messages/#use-of-link_directories-is-strongly-discouraged",
            "text": "ID : link_directory  Severity : warning  Explanation : Directories which are added to the search path with  link_directories()  will not be propagated to dependent packages. You should avoid this command or at least be aware that it might not work as expected in dependent packages.",
            "title": "use of link_directories() is strongly discouraged"
        },
        {
            "location": "/messages/#variable-var-is-modified",
            "text": "ID : critical_var_append  Severity : warning  Explanation : You have appended extra data to a critical CMake variable. This might break the build on different systems or affect the global catkin workspace in unintended ways.",
            "title": "variable var is modified"
        },
        {
            "location": "/messages/#variable-var-is-modified_1",
            "text": "ID : immutable_var  Severity : error  Explanation : You have modified a CMake variable that is initialized by CMake itself and must not be modified under any circumstances.",
            "title": "variable var is modified"
        },
        {
            "location": "/messages/#variable-var-is-overwritten",
            "text": "ID : critical_var_overwrite  Severity : error  Explanation : You have overwritten a critical CMake variable and its original content is lost. This will most likely break the build on different systems or affect the global catkin workspace in unintended ways.",
            "title": "variable var is overwritten"
        },
        {
            "location": "/messages/#variable-cmake_build_type-is-overwritten-unconditionally",
            "text": "ID : cmake_build_type  Severity : error  Explanation : If you wish to provide a default value for CMAKE_BUILD_TYPE, make sure that you do not overwrite user preferences. You should guard the  set()  command with an appropriate  if(NOT CMAKE_BUILD_TYPE)  block.",
            "title": "variable CMAKE_BUILD_TYPE is overwritten unconditionally"
        },
        {
            "location": "/api/",
            "text": "Register your own checks\n\n\ncatkin_lint\n checks are implemented as\nsubmodules, and interact with the main program\nvia callbacks. You can write your own checks for\n\ncatkin_lint\n and run them with the \n-c\n command line option.\nYou can also add them to your \n.catkin_lint\n configuration file\nto use them by default:\n\n\n[catkin_lint]\nextra_checks = my.customized.check my.other.check\n\n\n\nEach check is included via an entry function which setups\nthe callbacks for the check. The entry function has a single\nparameter \nlinter\n. The Linter object provides the following\nmethods:\n\n\nrequire()\n\n\nlinter.require(check_name)\n\n\n\n\nChecks may depend on the results of other checks.\nThe \nrequire\n method ensures that \ncheck_name\n\nis called exactly once. Circular dependencies of the\nform \nA->B->C->A\n will be detected and cause an\nexception. In particular, tests must not require themselves.\n\n\nregister_message()\n\n\n\n\nNote\n\n\nThis method was added in version 1.6.6\n\n\n\n\nlinter.register_message(msg_id, text, description=None)\n\n\n\n\nAdds a custom message that can be issued with \nreport()\n.\nMessage IDs must be unique. Valid characters are upper-case letters,\ndigits, and underscores only. Custom message IDs are also\nrequired to start with \nX_\n, to avoid conflicts with built-in\nIDs.\n\n\nThe text should be a short one-liner that concisely\ndescribes the problem. The description can be a paragraph\nor two for a more in-depth explanation. The description will reformat\nline breaks automatically to adjust for different terminal widths.\nAlso, you can have placeholders of the form \n%(keyword)s\n.\n\n\nadd_init_hook()\n\n\ndef callback(info):\n    ...\n\nlinter.add_init_hook(callback)\n\n\n\n\nRegisters an initialization hook that is called when\nthe lint check for a particular package begins.\n\n\nadd_command_hook()\n\n\ndef callback(info, cmd, args):\n    ...\n\nlinter.add_command_hook(name, callback)\n\n\n\n\nRegisters a command hook that is called each time the\nCMake parser encounters the command \nname\n. The command\nname and a list of its arguments are passed to the callback.\nAll command names are converted to lower-case.\n\n\nadd_final_hook()\n\n\ndef callback(info):\n    ...\n\nlinter.add_final_hook(callback)\n\n\n\n\nRegisters a final hook that is called when the CMake parser\nhas finished parsing the \nCMakeLists.txt\n file.\n\n\nexecute_hook()\n\n\nlinter.execute_hook(info, cmd, args)\n\n\n\n\nExecutes all registered command hooks for \ncmd\n. This is useful\nfor CMake wrapper macros, so you don't have to duplicate all checks\nfor the wrapped call. For example, the \ncuda_add_executable\n\ncommand hook calls the \nadd_executable\n hooks this way.\n\n\nInfo Object\n\n\nFor each linted package, \ncatkin_lint\n creates a\ndedicated info object that is passed to all callbacks.\nThe info object can be used to store relevant data.\nTypically, the init hook is used to initialize check-specific\nvariables in the info object. As a general rule, checks must not\nmodify variables they do not own, and each check must ensure it\nuses unique variable names that do not conflict with other checks.\n\n\nThe following variables are defined by \ncatkin_lint\n itself:\n\n\n\n\nenv\n:\n    A \nCatkinEnvironment\n object that provides information about\n    the ROS environment.\n\n\npath\n:\n    The filesystem path to the package source folder\n\n\nmanifest\n:\n    A \ncatkin_pkg.packages.Package\n object that is created from\n    information in the \npackage.xml\n.\n\n\nfile\n:\n    The currently parsed CMake file, relative to the package source\n    folder. Is either \nCMakeLists.txt\n or an include file. Only\n    valid in command hooks.\n\n\nline\n:\n    The line number of the currently processed CMake command. Only\n    valid in command hooks.\n\n\ncommands\n:\n    A set of all command names that have been encountered up to this point.\n\n\nfind_packages\n:\n    A set of all packages that have been configured with \nfind_package()\n\n    up to this point.\n\n\ntargets\n:\n    A set of all make targets that have been defined up to this point.\n\n\nexecutables\n:\n    A set of all executables that have been defined up to this point.\n\n\nlibraries\n:\n    A set of all libraries that have been defined up to this point.\n\n\nvar\n:\n    A dictionary of all known CMake variables. Note that many variables\n    have mocked values.\n\n\n\n\nreport()\n\n\ninfo.report(level, msg_id, **kwargs)\n\n\n\n\nReports a problem to the user. \nlevel\n must be one of\n\ncatkin_lint.linter.ERROR\n, \ncatkin_lint.linter.WARNING\n, or\n\ncatkin_lint.linter.NOTICE\n. The \nmsg_id\n refers to one\nof the defined diagnostic messages. Certain messages have placeholder\nvariables that must be specified, e.g. \ncmd\n for the command name. If\nyou wish to report a path, you should sanitize it with \nreport_path()\n\nfirst.\n\n\n\n\nNote\n\n\nStarting with version 1.6.0, you can target a report to a different\nfile location with the \nfile_location\n keyword argument.\n\n\n\n\nlocation_of()\n\n\n\n\nNote\n\n\nThis method was added in version 1.6.0\n\n\n\n\ninfo.location_of(cmd)\n\n\n\n\nReturns the file location of the most recent invocation of the CMake\ncommand \ncmd\n. This is useful if a problem is detected belatedly,\nbut should still be attributed to a particular faulty command.\n\n\nsource_relative_path()\n\n\ninfo.source_relative_path(path)\n\n\n\n\nReturns a path relative to the package source directory or\nan absolute path if the path is not within the package. Can handle\n\n${CMAKE_CURRENT_SOURCE_DIR}\n correctly.\n\n\nbinary_relative_path()\n\n\ninfo.binary_relative_path(path)\n\n\n\n\nReturns a path relative to the package build directory or\nan absolute path if the path is not inside the build directory. Can handle\n\n${CMAKE_CURRENT_BINARY_DIR}\n correctly.\n\n\nreal_path()\n\n\ninfo.real_path(path)\n\n\n\n\nReturns the actual file system path for relative package path as\nreturned by \nsource_relative_path()\n.\n\n\nis_internal_path()\n\n\ninfo.is_internal_path(path)\n\n\n\n\nReturns \nTrue\n if the path is either below the package source\ndirectory or the package build directory.\n\n\npath_class()\n\n\n\n\nNote\n\n\nThis method was added in version 1.5.0\n\n\n\n\ninfo.path_class(path)\n\n\n\n\nReturns a value from the \nPathClass\n class, which can be one of\n\nSOURCE\n, \nBINARY\n, \nDISCOVERED\n, or \nOTHER\n.\n\n\nis_valid_path()\n\n\n\n\nNote\n\n\nThis method was added in version 1.5.0\n\n\n\n\ninfo.is_valid_path(path, valid=[PathClass.SOURCE, PathClass.BINARY, PathClass.DISCOVERED])\n\n\n\n\nReturns \nTrue\n if the path belongs to any of the valid path classes. By default,\nany path is accepted which is either in the source tree, the a built file, or\na path discovered by the appropriate CMake functions such as \nfind_file()\n.\n\n\nis_existing_path()\n\n\n\n\nNote\n\n\nThis method was added in version 1.5.0\n\n\n\n\ninfo.is_existing_path(path, check=os.path.exists, require_source_folder=False, discovered_path_ok=True)\n\n\n\n\nReturns \nTrue\n if the path is a valid path argument for a catkin command, which\nmeans it's either an existing file or a file that will be generated by \nconfigure_file\n\nor \nadd_custom_command\n. If \ndiscovered_path_ok\n is \nTrue\n, then a path \ndiscovered by \nfind_package()\n, \nfind_path()\n, \nfind_file()\n or \nfind_library()\n\nwill be accepted as well. If \nrequire_source_folder\n is \nTrue\n, then any files\nwhich are not physically located within the source folder will be rejected.\n\n\nreport_path()\n\n\ninfo.report_path(path)\n\n\n\n\nReturns \npath\n in a form that is suitable for user consumption, i.e., as argument of\n\nreport()\n. In particular, this will ensure that mock paths are rewritten in a form\nthat is informative for the user.\n\n\nis_catkin_install_destination()\n\n\ninfo.is_catkin_install_destination(path, subdir=None)\n\n\n\n\nReturns \nTrue\n if the path points to the install space of\nthe catkin workspace. If \nsubdir\n is not \nNone\n, it checks\nif the path points to the specified subdirectory in the install\nspace.\n\n\nCatkinEnvironment object\n\n\nget_package_type()\n\n\nenv.get_package_type(name)\n\n\n\n\nReturns one of the following values:\n\n\n\n\ncatkin_lint.environment.PackageType.CATKIN\n if \nname\n is a catkin package\n\n\ncatkin_lint.environment.PackageType.OTHER\n if \nname\n is a package but not catkin-based\n\n\ncatkin_lint.environment.PackageType.UNKNOWN\n if \nname\n is not a known package\n\n\ncatkin_lint.environment.PackageType.INDETERMINATE\n if the package type could not be determined\n\n\n\n\nis_catkin_pkg()\n\n\nenv.is_catkin_pkg(name)\n\n\n\n\nReturns \nTrue\n if \nname\n is a catkin package. May return\nwrong results if \nenv.ok\n is not \nTrue\n.\n\n\n\n\nWarning\n\n\nThis function is deprecated since version 1.6.10.\nPlease use \nget_package_type()\n instead.\n\n\n\n\nis_known_pkg()\n\n\nenv.is_known_pkg(name)\n\n\n\n\nReturns \nTrue\n if \nname\n is a known package. May return\nwrong results if \nenv.ok\n is not \nTrue\n.\n\n\n\n\nWarning\n\n\nThis function is deprecated since version 1.6.10.\nPlease use \nget_package_type()\n instead.\n\n\n\n\nok\n\n\n    env.ok\n\n\n\n\nIs \nTrue\n if the list of ROS dependencies was properly\ninitialized.\n\n\n\n\nWarning\n\n\nThis property is deprecated since version 1.6.10.\nPlease use \nget_package_type()\n instead.",
            "title": "API"
        },
        {
            "location": "/api/#register-your-own-checks",
            "text": "catkin_lint  checks are implemented as\nsubmodules, and interact with the main program\nvia callbacks. You can write your own checks for catkin_lint  and run them with the  -c  command line option.\nYou can also add them to your  .catkin_lint  configuration file\nto use them by default:  [catkin_lint]\nextra_checks = my.customized.check my.other.check  Each check is included via an entry function which setups\nthe callbacks for the check. The entry function has a single\nparameter  linter . The Linter object provides the following\nmethods:",
            "title": "Register your own checks"
        },
        {
            "location": "/api/#require",
            "text": "linter.require(check_name)  Checks may depend on the results of other checks.\nThe  require  method ensures that  check_name \nis called exactly once. Circular dependencies of the\nform  A->B->C->A  will be detected and cause an\nexception. In particular, tests must not require themselves.",
            "title": "require()"
        },
        {
            "location": "/api/#register_message",
            "text": "Note  This method was added in version 1.6.6   linter.register_message(msg_id, text, description=None)  Adds a custom message that can be issued with  report() .\nMessage IDs must be unique. Valid characters are upper-case letters,\ndigits, and underscores only. Custom message IDs are also\nrequired to start with  X_ , to avoid conflicts with built-in\nIDs.  The text should be a short one-liner that concisely\ndescribes the problem. The description can be a paragraph\nor two for a more in-depth explanation. The description will reformat\nline breaks automatically to adjust for different terminal widths.\nAlso, you can have placeholders of the form  %(keyword)s .",
            "title": "register_message()"
        },
        {
            "location": "/api/#add_init_hook",
            "text": "def callback(info):\n    ...\n\nlinter.add_init_hook(callback)  Registers an initialization hook that is called when\nthe lint check for a particular package begins.",
            "title": "add_init_hook()"
        },
        {
            "location": "/api/#add_command_hook",
            "text": "def callback(info, cmd, args):\n    ...\n\nlinter.add_command_hook(name, callback)  Registers a command hook that is called each time the\nCMake parser encounters the command  name . The command\nname and a list of its arguments are passed to the callback.\nAll command names are converted to lower-case.",
            "title": "add_command_hook()"
        },
        {
            "location": "/api/#add_final_hook",
            "text": "def callback(info):\n    ...\n\nlinter.add_final_hook(callback)  Registers a final hook that is called when the CMake parser\nhas finished parsing the  CMakeLists.txt  file.",
            "title": "add_final_hook()"
        },
        {
            "location": "/api/#execute_hook",
            "text": "linter.execute_hook(info, cmd, args)  Executes all registered command hooks for  cmd . This is useful\nfor CMake wrapper macros, so you don't have to duplicate all checks\nfor the wrapped call. For example, the  cuda_add_executable \ncommand hook calls the  add_executable  hooks this way.",
            "title": "execute_hook()"
        },
        {
            "location": "/api/#info-object",
            "text": "For each linted package,  catkin_lint  creates a\ndedicated info object that is passed to all callbacks.\nThe info object can be used to store relevant data.\nTypically, the init hook is used to initialize check-specific\nvariables in the info object. As a general rule, checks must not\nmodify variables they do not own, and each check must ensure it\nuses unique variable names that do not conflict with other checks.  The following variables are defined by  catkin_lint  itself:   env :\n    A  CatkinEnvironment  object that provides information about\n    the ROS environment.  path :\n    The filesystem path to the package source folder  manifest :\n    A  catkin_pkg.packages.Package  object that is created from\n    information in the  package.xml .  file :\n    The currently parsed CMake file, relative to the package source\n    folder. Is either  CMakeLists.txt  or an include file. Only\n    valid in command hooks.  line :\n    The line number of the currently processed CMake command. Only\n    valid in command hooks.  commands :\n    A set of all command names that have been encountered up to this point.  find_packages :\n    A set of all packages that have been configured with  find_package() \n    up to this point.  targets :\n    A set of all make targets that have been defined up to this point.  executables :\n    A set of all executables that have been defined up to this point.  libraries :\n    A set of all libraries that have been defined up to this point.  var :\n    A dictionary of all known CMake variables. Note that many variables\n    have mocked values.",
            "title": "Info Object"
        },
        {
            "location": "/api/#report",
            "text": "info.report(level, msg_id, **kwargs)  Reports a problem to the user.  level  must be one of catkin_lint.linter.ERROR ,  catkin_lint.linter.WARNING , or catkin_lint.linter.NOTICE . The  msg_id  refers to one\nof the defined diagnostic messages. Certain messages have placeholder\nvariables that must be specified, e.g.  cmd  for the command name. If\nyou wish to report a path, you should sanitize it with  report_path() \nfirst.   Note  Starting with version 1.6.0, you can target a report to a different\nfile location with the  file_location  keyword argument.",
            "title": "report()"
        },
        {
            "location": "/api/#location_of",
            "text": "Note  This method was added in version 1.6.0   info.location_of(cmd)  Returns the file location of the most recent invocation of the CMake\ncommand  cmd . This is useful if a problem is detected belatedly,\nbut should still be attributed to a particular faulty command.",
            "title": "location_of()"
        },
        {
            "location": "/api/#source_relative_path",
            "text": "info.source_relative_path(path)  Returns a path relative to the package source directory or\nan absolute path if the path is not within the package. Can handle ${CMAKE_CURRENT_SOURCE_DIR}  correctly.",
            "title": "source_relative_path()"
        },
        {
            "location": "/api/#binary_relative_path",
            "text": "info.binary_relative_path(path)  Returns a path relative to the package build directory or\nan absolute path if the path is not inside the build directory. Can handle ${CMAKE_CURRENT_BINARY_DIR}  correctly.",
            "title": "binary_relative_path()"
        },
        {
            "location": "/api/#real_path",
            "text": "info.real_path(path)  Returns the actual file system path for relative package path as\nreturned by  source_relative_path() .",
            "title": "real_path()"
        },
        {
            "location": "/api/#is_internal_path",
            "text": "info.is_internal_path(path)  Returns  True  if the path is either below the package source\ndirectory or the package build directory.",
            "title": "is_internal_path()"
        },
        {
            "location": "/api/#path_class",
            "text": "Note  This method was added in version 1.5.0   info.path_class(path)  Returns a value from the  PathClass  class, which can be one of SOURCE ,  BINARY ,  DISCOVERED , or  OTHER .",
            "title": "path_class()"
        },
        {
            "location": "/api/#is_valid_path",
            "text": "Note  This method was added in version 1.5.0   info.is_valid_path(path, valid=[PathClass.SOURCE, PathClass.BINARY, PathClass.DISCOVERED])  Returns  True  if the path belongs to any of the valid path classes. By default,\nany path is accepted which is either in the source tree, the a built file, or\na path discovered by the appropriate CMake functions such as  find_file() .",
            "title": "is_valid_path()"
        },
        {
            "location": "/api/#is_existing_path",
            "text": "Note  This method was added in version 1.5.0   info.is_existing_path(path, check=os.path.exists, require_source_folder=False, discovered_path_ok=True)  Returns  True  if the path is a valid path argument for a catkin command, which\nmeans it's either an existing file or a file that will be generated by  configure_file \nor  add_custom_command . If  discovered_path_ok  is  True , then a path \ndiscovered by  find_package() ,  find_path() ,  find_file()  or  find_library() \nwill be accepted as well. If  require_source_folder  is  True , then any files\nwhich are not physically located within the source folder will be rejected.",
            "title": "is_existing_path()"
        },
        {
            "location": "/api/#report_path",
            "text": "info.report_path(path)  Returns  path  in a form that is suitable for user consumption, i.e., as argument of report() . In particular, this will ensure that mock paths are rewritten in a form\nthat is informative for the user.",
            "title": "report_path()"
        },
        {
            "location": "/api/#is_catkin_install_destination",
            "text": "info.is_catkin_install_destination(path, subdir=None)  Returns  True  if the path points to the install space of\nthe catkin workspace. If  subdir  is not  None , it checks\nif the path points to the specified subdirectory in the install\nspace.",
            "title": "is_catkin_install_destination()"
        },
        {
            "location": "/api/#catkinenvironment-object",
            "text": "",
            "title": "CatkinEnvironment object"
        },
        {
            "location": "/api/#get_package_type",
            "text": "env.get_package_type(name)  Returns one of the following values:   catkin_lint.environment.PackageType.CATKIN  if  name  is a catkin package  catkin_lint.environment.PackageType.OTHER  if  name  is a package but not catkin-based  catkin_lint.environment.PackageType.UNKNOWN  if  name  is not a known package  catkin_lint.environment.PackageType.INDETERMINATE  if the package type could not be determined",
            "title": "get_package_type()"
        },
        {
            "location": "/api/#is_catkin_pkg",
            "text": "env.is_catkin_pkg(name)  Returns  True  if  name  is a catkin package. May return\nwrong results if  env.ok  is not  True .   Warning  This function is deprecated since version 1.6.10.\nPlease use  get_package_type()  instead.",
            "title": "is_catkin_pkg()"
        },
        {
            "location": "/api/#is_known_pkg",
            "text": "env.is_known_pkg(name)  Returns  True  if  name  is a known package. May return\nwrong results if  env.ok  is not  True .   Warning  This function is deprecated since version 1.6.10.\nPlease use  get_package_type()  instead.",
            "title": "is_known_pkg()"
        },
        {
            "location": "/api/#ok",
            "text": "env.ok  Is  True  if the list of ROS dependencies was properly\ninitialized.   Warning  This property is deprecated since version 1.6.10.\nPlease use  get_package_type()  instead.",
            "title": "ok"
        }
    ]
}