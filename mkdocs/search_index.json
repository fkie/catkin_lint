{
    "docs": [
        {
            "location": "/",
            "text": "catkin_lint\n\n\nOverview\n\n\ncatkin_lint\n checks package configurations for the\n\ncatkin\n build system of\n\nROS\n. It runs a static analysis of the \npackage.xml\n\nand \nCMakeLists.txt\n files in your package, and it will detect and report a\nnumber of common problems.\n\n\nInstallation\n\n\nInstall Ubuntu packages\n\n\nPrebuilt packages are available from the \nROS repository\n.\nIf you have installed ROS already, downloading \ncatkin_lint\n is as simple as:\n\n\n$ sudo apt-get install python-catkin-lint\n\n\n\n\nAlternatively, you can use \nTimo's PPA\n on Launchpad:\n\n\n$ sudo add-apt-repository ppa:roehling/latest\n$ sudo apt-get update\n$ sudo apt-get install python-catkin-lint\n\n\n\n\nDownload from PyPI\n\n\nYou can download and install \ncatkin_lint\n from the \nPython Package Index\n\nwith:\n\n\n$ sudo pip install catkin_lint\n\n\n\n\nInstall from Source\n\n\nYou can clone \ncatkin_lint\n from \nGitHub\n:\n\n\n$ git clone https://github.com/fkie/catkin_lint\n$ cd catkin_lint\n$ sudo python setup.py install\n\n\n\n\n\n\n\n\nBuild your own Debian packages\n\n\nIf your distribution is not supported, you can build yor own packages:\n\n\n$ sudo apt-get install dpkg-dev\n$ git clone https://github.com/fkie/catkin_lint\n$ cd catkin_lint\n$ git checkout debian\n$ ./debian/rules make-orig-tar\n$ dpkg-buildpackage -tc -uc -us\n$ sudo dpkg -i ../python-catkin-lint_*_all.deb\n\n\n\n\n\n\nRunning\n\n\nIf \ncatkin_lint\n is invoked with one or more paths as parameters, it\nsearches for packages recursively and checks all of them. Alternatively, the\n\n--pkg\n option can be used to add the path of a particular ROS package.\n\n\nIf neither paths nor packages are specified, \ncatkin_lint\n looks for a\npackage in the current working directory.\n\n\nA more detailed list of command line options can be obtained by running\n\n\n$ catkin_lint --help\n\n\n\n\nLimitations\n\n\ncatkin_lint\n works by emulating the way CMake processes your package\nduring a build. However, since it does not \nreally\n build anything,\nthe emulation is not perfect. For instance,\n\n\n\n\ncatkin_lint\n does not evaluate boolean expressions in \nif()\n clauses\n  There is some special purpose code to detect \nif(CATKIN_ENABLE_TESTING)\n blocks,\n  but in general, \ncatkin_lint\n will just execute all statements, even mutually exclusive\n  \nif()\n/\nelse()\n blocks.\n\n\ncatkin_lint\n uses mock values for \nfind_package()\n, \nfind_file()\n, and \nfind_library()\n\n  calls. That means that those function calls will always succeed and \"find\" something.\n\n\ncatkin_lint\n ignores \nfunction()\n definitions. It does, however, expand macros and\n  \nforeach()\n loops.\n\n\n\n\nDiagnostic Levels\n\n\ncatkin_lint\n has \nmessages\n in three different categories:\nerrors, warnings, and notices. The \n-W\n option controls which problems\nare reported to the user:\n\n\n\n\n-W0\n: only errors are reported\n\n\n-W1\n: errors and warnings are reported (this is the default)\n\n\n-W2\n: errors, warnings, and notices are reported\n\n\n\n\nNormally, \ncatkin_lint\n returns a non-zero exit code if and only\nif errors occurred. The \n--strict\n option causes \ncatkin_lint\n to\ntreat any reported problem as error.\n\n\nErrors\n\n\nErrors are severe enough to break the build and/or produce unintended\nside effects. Usually, they violate the rules outlined in the\n\ncatkin manual\n.\n\n\nWarnings\n\n\nPotential errors which may indicate a bug in your package but may be\njustified for reasons \ncatkin_lint\n cannot discern. Constructs which\ntrigger a warning can usually be modified in a way that is functionally\nequivalent but more robust.\n\n\nNotices\n\n\nIssues which are not objectionable from a technical view point but\nshould  be addressed to improve the quality of the package. Many notices\nhighlight violations of the recommendations and best practises from the\ncatkin manual.",
            "title": "Home"
        },
        {
            "location": "/#catkin_lint",
            "text": "",
            "title": "catkin_lint"
        },
        {
            "location": "/#overview",
            "text": "catkin_lint  checks package configurations for the catkin  build system of ROS . It runs a static analysis of the  package.xml \nand  CMakeLists.txt  files in your package, and it will detect and report a\nnumber of common problems.",
            "title": "Overview"
        },
        {
            "location": "/#installation",
            "text": "",
            "title": "Installation"
        },
        {
            "location": "/#install-ubuntu-packages",
            "text": "Prebuilt packages are available from the  ROS repository .\nIf you have installed ROS already, downloading  catkin_lint  is as simple as:  $ sudo apt-get install python-catkin-lint  Alternatively, you can use  Timo's PPA  on Launchpad:  $ sudo add-apt-repository ppa:roehling/latest\n$ sudo apt-get update\n$ sudo apt-get install python-catkin-lint",
            "title": "Install Ubuntu packages"
        },
        {
            "location": "/#download-from-pypi",
            "text": "You can download and install  catkin_lint  from the  Python Package Index \nwith:  $ sudo pip install catkin_lint",
            "title": "Download from PyPI"
        },
        {
            "location": "/#install-from-source",
            "text": "You can clone  catkin_lint  from  GitHub :  $ git clone https://github.com/fkie/catkin_lint\n$ cd catkin_lint\n$ sudo python setup.py install",
            "title": "Install from Source"
        },
        {
            "location": "/#build-your-own-debian-packages",
            "text": "If your distribution is not supported, you can build yor own packages:  $ sudo apt-get install dpkg-dev\n$ git clone https://github.com/fkie/catkin_lint\n$ cd catkin_lint\n$ git checkout debian\n$ ./debian/rules make-orig-tar\n$ dpkg-buildpackage -tc -uc -us\n$ sudo dpkg -i ../python-catkin-lint_*_all.deb",
            "title": "Build your own Debian packages"
        },
        {
            "location": "/#running",
            "text": "If  catkin_lint  is invoked with one or more paths as parameters, it\nsearches for packages recursively and checks all of them. Alternatively, the --pkg  option can be used to add the path of a particular ROS package.  If neither paths nor packages are specified,  catkin_lint  looks for a\npackage in the current working directory.  A more detailed list of command line options can be obtained by running  $ catkin_lint --help",
            "title": "Running"
        },
        {
            "location": "/#limitations",
            "text": "catkin_lint  works by emulating the way CMake processes your package\nduring a build. However, since it does not  really  build anything,\nthe emulation is not perfect. For instance,   catkin_lint  does not evaluate boolean expressions in  if()  clauses\n  There is some special purpose code to detect  if(CATKIN_ENABLE_TESTING)  blocks,\n  but in general,  catkin_lint  will just execute all statements, even mutually exclusive\n   if() / else()  blocks.  catkin_lint  uses mock values for  find_package() ,  find_file() , and  find_library() \n  calls. That means that those function calls will always succeed and \"find\" something.  catkin_lint  ignores  function()  definitions. It does, however, expand macros and\n   foreach()  loops.",
            "title": "Limitations"
        },
        {
            "location": "/#diagnostic-levels",
            "text": "catkin_lint  has  messages  in three different categories:\nerrors, warnings, and notices. The  -W  option controls which problems\nare reported to the user:   -W0 : only errors are reported  -W1 : errors and warnings are reported (this is the default)  -W2 : errors, warnings, and notices are reported   Normally,  catkin_lint  returns a non-zero exit code if and only\nif errors occurred. The  --strict  option causes  catkin_lint  to\ntreat any reported problem as error.",
            "title": "Diagnostic Levels"
        },
        {
            "location": "/#errors",
            "text": "Errors are severe enough to break the build and/or produce unintended\nside effects. Usually, they violate the rules outlined in the catkin manual .",
            "title": "Errors"
        },
        {
            "location": "/#warnings",
            "text": "Potential errors which may indicate a bug in your package but may be\njustified for reasons  catkin_lint  cannot discern. Constructs which\ntrigger a warning can usually be modified in a way that is functionally\nequivalent but more robust.",
            "title": "Warnings"
        },
        {
            "location": "/#notices",
            "text": "Issues which are not objectionable from a technical view point but\nshould  be addressed to improve the quality of the package. Many notices\nhighlight violations of the recommendations and best practises from the\ncatkin manual.",
            "title": "Notices"
        },
        {
            "location": "/messages/",
            "text": "catkin_lint diagnostic messages\n\n\nThis is a list of all messages which might be shown by \ncatkin_lint\n.\nEach diagnostic has a unique ID (such as \ncatkin_order_violation\n),\nwhich you can use to disable certain messages, either with the command line option\n\n--ignore ID\n, or by adding a pragma line \n#catkin_lint: ignore ID\n at the beginning\nof the CMakeLists.txt file. As a third option, you can add a pragma line \n#catkin_lint: ignore_once ID\n\nright before the offending statement. Use this if you want to ignore a particular instance\nof a problem but still be notified if the same problem occurs someplace else. You may\nalso use \n#catkin_lint: report ID\n at any point to override a previous \nignore\n.\n\n\n'\npkg\n' in find_package(catkin) is not a catkin package\n\n\n\n\nID\n: no_catkin_component\n\n\nSeverity\n: error\n\n\nExplanation\n: The find_package(catkin) call can list other catkin packages as dependencies with the COMPONENTS keyword. This is shorter than multiple find_package() calls, but does not work for system dependencies.\n\n\n\n\ncmd\n() is called before find_package(catkin)\n\n\n\n\nID\n: catkin_order_violation\n\n\nSeverity\n: error\n\n\nExplanation\n: Catkin macros cannot be called before catkin has been configured with find_package(catkin).\n\n\n\n\ncmd\n() is deprecated\n\n\n\n\nID\n: deprecated_rosbuild\n\n\nSeverity\n: warning, error\n\n\nExplanation\n: This construct was intended to facilitate the migration from Rosbuild to Catkin. It is deprecated and should not be used any more.\n\n\n\n\ncmd\n() is not allowed in meta packages\n\n\n\n\nID\n: invalid_meta_command\n\n\nSeverity\n: error\n\n\nExplanation\n: Meta packages do not contain code or data and are merely dependency lists with very strict requirements for the format of the CMakeLists.txt file.\n\n\n\n\ncmd\n() needs missing directory '\ndirectory\n'\n\n\n\n\nID\n: missing_directory\n\n\nSeverity\n: error\n\n\nExplanation\n: This catkin command processes a particular directory which is missing from the package source folder.\n\n\n\n\ncmd\n() needs missing file '\nfile\n'\n\n\n\n\nID\n: missing_file\n\n\nSeverity\n: error\n\n\nExplanation\n: This catkin command processes a particular file which is missing from the package source folder.\n\n\n\n\ncmd\n() should be all lower-case\n\n\n\n\nID\n: cmd_case\n\n\nSeverity\n: notice\n\n\nExplanation\n: The catkin manual recommends that all commands be written in lower case.\n\n\n\n\ncmd\n() used without if(CATKIN_ENABLE_TESTING)\n\n\n\n\nID\n: unguarded_test_cmd\n\n\nSeverity\n: error\n\n\nExplanation\n: You have used a test command without properly guarding it by a if(CATKIN_ENABLE_TESTING) block.\n\n\n\n\ncmd\n() uses directory '\ndirectory\n' which is not in package\n\n\n\n\nID\n: external_directory\n\n\nSeverity\n: warning\n\n\nExplanation\n: This catkin command uses a directory which lies outside of the package source folder. While this may work in your particular setup, you cannot assume file locations in general. Use find_path() to detect external locations insteed.\n\n\n\n\ncmd\n() uses file '\nfile\n' which is not in package\n\n\n\n\nID\n: external_file\n\n\nSeverity\n: warning, error\n\n\nExplanation\n: This catkin command uses a file which lies outside of the package source folder. While this may work in your particular setup, you cannot assume file locations in general. Use find_file() to detect external locations insteed.\n\n\n\n\nexport\n plugin file '\nfile\n' is not installed to ${CATKIN_PACKAGE_SHARE_DESTINATION}\n\n\n\n\nID\n: plugin_missing_install\n\n\nSeverity\n: warning, error\n\n\nExplanation\n: Your package can be used from the devel space but cannot be installed properly, because a plugin declaration file which is listed in your package.xml is not installed to the correct location.\n\n\n\n\nexport\n plugin file reference must start with '${prefix}/'\n\n\n\n\nID\n: plugin_export_prefix\n\n\nSeverity\n: error\n\n\nExplanation\n: The ${prefix} variable is carefully overloaded to work with both devel space and install space and must be used in all \n tags.\n\n\n\n\nexport\n plugin refers to missing file '\nfile\n'\n\n\n\n\nID\n: plugin_missing_file\n\n\nSeverity\n: error\n\n\nExplanation\n: A plugin declaration file which is listed in your package.xml is missing from the package source folder.\n\n\n\n\nfirst_cmd\n() is called before \nsecond_cmd\n()\n\n\n\n\nID\n: order_violation\n\n\nSeverity\n: error\n\n\nExplanation\n: Certain configuration macros must be called in a specific order as specified by the catkin build manual. Failure to do so may lead to improper configuration of the package and build problems.\n\n\n\n\nold_cmd\n() is deprecated, use \nnew_cmd\n() instead\n\n\n\n\nID\n: deprecated_cmd\n\n\nSeverity\n: error\n\n\nExplanation\n: Some macros have been deprecated and replaced by newer versions. Please upgrade your CMakeLists.txt to ensure compatibility with future caktin versions.\n\n\n\n\ntype\n_depend '\npkg\n' is not listed in catkin_package()\n\n\n\n\nID\n: missing_catkin_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: You have specified a catkin run dependency but failed to list it in the CATKIN_DEPENDS stanza of the catkin_package() call.\n\n\n\n\nwrong_type\n_depend '\npkg\n' should be a \nright_type\n_depend\n\n\n\n\nID\n: wrong_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: You have listed a package as the wrong dependency type. build_depends are needed to build your package (as in compile the declared executables and libraries). run_depends are needed at runtime to run the nodes or use the libraries and exported headers in other projects. buildtool_depends are significant only for cross-compiling; in that case, buildtool_depends are host architecture (and run during the build process) while build_depends are target architecture (and are linked against). test_depends are additional run_depends which only apply to unit tests.\n\n\n\n\nCMake module '\nold_module\n' is deprecated, use '\nnew_module\n' instead\n\n\n\n\nID\n: deprecated_cmake_module\n\n\nSeverity\n: warning\n\n\nExplanation\n: Some CMake modules have been provided by cmake_modules in the past, but are now provided by the system package or CMake itself. Please upgrade your CMakeLists.txt to ensure compatibility with future catkin versions.\n\n\n\n\nOS error: \nmsg\n\n\n\n\nID\n: os_error\n\n\nSeverity\n: error\n\n\nExplanation\n: An operating system error has occured. This is not a linting problem per se but might be caused by a missing or unreadable file.\n\n\n\n\ncatkin_metapackage() in regular package\n\n\n\n\nID\n: catkin_meta_vs_pkg\n\n\nSeverity\n: error\n\n\nExplanation\n: The catkin_metapackage() command signals your intent to declare a meta package, but the package.xml does not contain a \n tag.\n\n\n\n\ncatkin_package() exports non-package include path\n\n\n\n\nID\n: external_include_path\n\n\nSeverity\n: error\n\n\nExplanation\n: You listed one or more include paths in the INCLUDE_DIRS stanza of your catkin_package() call which are not part of your package. If you want to export include paths of other modules, use find_package(), find_path(), and/or find_library() and add the dependency to the DEPENDS stanza.\n\n\n\n\ncatkin_package() exports package include path that is not installed\n\n\n\n\nID\n: missing_install_include\n\n\nSeverity\n: warning, error\n\n\nExplanation\n: Your package can be used from the devel space but cannot be installed properly, because the header files will not be copied to the proper location.\n\n\n\n\ncatkin_package() exports pkg-config module '\npkg\n'\n\n\n\n\nID\n: exported_pkg_config\n\n\nSeverity\n: error\n\n\nExplanation\n: Although CMake can invoke pkg-config to detect other modules, this does not work well with catkin, as pkg-config may require you to add link directories. Use the results of pkg_check_module() as hint for find_path() and find_library() instead.\n\n\n\n\ncatkin_package() in meta package\n\n\n\n\nID\n: catkin_pkg_vs_meta\n\n\nSeverity\n: error\n\n\nExplanation\n: Meta packages use the catkin_metapackage() command to declare a meta package. This performs additional checks and ensures that all requirements are met.\n\n\n\n\ncatkin_package() lists '\npkg\n' as catkin package but it is not\n\n\n\n\nID\n: system_as_catkin_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: In your catkin_package() call, you have listed a system dependency in the CATKIN_DEPENDS stanza, but it belongs in the DEPENDS stanza instead.\n\n\n\n\ncatkin_package() lists '\npkg\n' as system package but it is not\n\n\n\n\nID\n: catkin_as_system_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: In your catkin_package() call, you have listed a catkin package in the DEPENDS stanza, but it belongs in the CATKIN_DEPENDS stanza instead.\n\n\n\n\ncatkin_package() lists unconfigured system package '\npkg\n'\n\n\n\n\nID\n: unconfigured_system_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: In order to export a system package as dependency, you must either call find_package(\npkg\n) first or initialize the \npkg\n_INCLUDE_DIRS and \npkg\n_LIBRARIES variables manually.\n\n\n\n\ncondition '\ncond\n' is ambiguous\n\n\n\n\nID\n: ambiguous_condition\n\n\nSeverity\n: warning\n\n\nExplanation\n: Historically, the if() command will interpret a single token as a variable name and transparently resolve it if possible. Explicit variable references like if(${var}) can lead to incorrect results if ${var} resolves to a different variable name. Use if(var) instead.\n\n\n\n\nduplicate \ncmd\n()\n\n\n\n\nID\n: duplicate_cmd\n\n\nSeverity\n: error\n\n\nExplanation\n: You have called this command more than once, but this does not make sense. If the calls use different arguments, consolidate them into a single call, otherwise simply remove the second.\n\n\n\n\nduplicate find_package(\npkg\n)\n\n\n\n\nID\n: duplicate_find\n\n\nSeverity\n: error\n\n\nExplanation\n: The find_package() searches for a dependency and caches the result. A second call will be silently ignored. In particular, if you specify different arguments to the second call, those will not have any effect at all, which is most likely not what you want.\n\n\n\n\nduplicate include path ${\npkg\n_INCLUDE_DIRS}\n\n\n\n\nID\n: duplicate_build_include\n\n\nSeverity\n: warning\n\n\nExplanation\n: Include paths of packages listed in the find_package(catkin) command are added implicitly by the ${catkin_INCLUDE_DIRS} variable. There is no need to add it a second time.\n\n\n\n\nenvironment variables should not be used\n\n\n\n\nID\n: env_var\n\n\nSeverity\n: warning\n\n\nExplanation\n: The behavior of your build should not depend on any environment variables.\n\n\n\n\nexported include path '\npath\n' does not exist\n\n\n\n\nID\n: missing_export_include_path\n\n\nSeverity\n: error\n\n\nExplanation\n: You have listed an invalid include path in the INCLUDE_DIRS stanza of the catkin_package() command.\n\n\n\n\nexported library '\ntarget\n' cannot have different output name\n\n\n\n\nID\n: export_lib_renamed\n\n\nSeverity\n: error\n\n\nExplanation\n: Due to a limitation of the catkin build system, the catkin_package() library export function will break if the logical target name is not equal to the actual library name.\n\n\n\n\nexported library '\ntarget\n' is not a library\n\n\n\n\nID\n: export_lib_not_lib\n\n\nSeverity\n: error\n\n\nExplanation\n: You listed a library in the LIBRARIES stanza of your catkin_package() call, but it really is an executable.\n\n\n\n\nexported library '\ntarget\n' is not installed\n\n\n\n\nID\n: uninstalled_export_lib\n\n\nSeverity\n: warning, error\n\n\nExplanation\n: Your package can be used from the devel space but cannot be installed properly, because a library that is exported via catkin_package() will not be copied to the proper location.\n\n\n\n\nexported package include path but no exported library\n\n\n\n\nID\n: missing_export_lib\n\n\nSeverity\n: warning\n\n\nExplanation\n: Your package exports a package include path and builds at least one library, which suggests that you may want to export the library to other packages as well.\n\n\n\n\nexported target '\ntarget\n' is not defined\n\n\n\n\nID\n: undefined_target\n\n\nSeverity\n: error\n\n\nExplanation\n: Your package provides a CMake target to other packages, but the listed target is not defined at all.\n\n\n\n\nextra arguments in \ncmd\n()\n\n\n\n\nID\n: endblock_args\n\n\nSeverity\n: notice\n\n\nExplanation\n: The catkin manual recommends that \ncmd\n and other end-of-block statements have no arguments. If you have nested blocks, you should indent them properly instead.\n\n\n\n\nfile '\nscript\n' is executable but not installed\n\n\n\n\nID\n: uninstalled_script\n\n\nSeverity\n: warning\n\n\nExplanation\n: Your package contains a file that is marked as executable but not installed. If it is a script intended to be run (e.g. with rosrun), it will not work outside the devel tree. If it is not an executable script, you should fix the file permissions.\n\n\n\n\nfile setup.py found but no catkin_python_setup() call\n\n\n\n\nID\n: missing_python_setup\n\n\nSeverity\n: error\n\n\nExplanation\n: The catkin_python_setup() call is required to properly configure python modules, and the existing setup.py indicates that your package provides one or more python modules.\n\n\n\n\nfind_package(\npkg\n) before find_package(cmake_modules)\n\n\n\n\nID\n: missing_cmake_modules\n\n\nSeverity\n: warning\n\n\nExplanation\n: You need to find_package() cmake_modules before you can use one of its custom configuration modules.\n\n\n\n\nfind_package(\npkg\n) has no REQUIRED option\n\n\n\n\nID\n: missing_required\n\n\nSeverity\n: warning, error\n\n\nExplanation\n: The package cannot build without this dependency, so it should be marked as REQUIRED accordingly. Use if(\npkg\n_FOUND) clauses to use optional packages.\n\n\n\n\ngenerate_messages() called but no message declared\n\n\n\n\nID\n: unused_generate_msg\n\n\nSeverity\n: warning\n\n\nExplanation\n: The generate_messages() call creates the messages, services, and actions which are declared in your package. If your package does not supply any of these, you do not have to call generate_messages() at all.\n\n\n\n\nglobal variable '\nvar\n' should contain project name\n\n\n\n\nID\n: global_var_collision\n\n\nSeverity\n: notice\n\n\nExplanation\n: Global variables and options are stored in the cache. You should prefix your variable names with the project name to avoid name collisions with other packages.\n\n\n\n\ninclude path '\npath\n' is exported but not used for the build\n\n\n\n\nID\n: missing_build_include\n\n\nSeverity\n: warning\n\n\nExplanation\n: You have listed an include path in the INCLUDE_DIRS stanza of the catkin_package() command, but that path is not mentioned in any include_directories() call.\n\n\n\n\ninclude paths '\npath\n' and '\nparent_path\n' are ambiguous\n\n\n\n\nID\n: ambiguous_build_include\n\n\nSeverity\n: warning\n\n\nExplanation\n: You have used two include paths where one is a parent of the other. Thus the same headers can be included with two different include paths which may confuse users. It is recommended that you keep your include paths consistent.\n\n\n\n\ninstall(\ntype\n ... \ndest\n) is not one of the ${CATKIN_*_DESTINATION}s\n\n\n\n\nID\n: install_destination\n\n\nSeverity\n: warning\n\n\nExplanation\n: Catkin provides a number of standard variables to specify installation folders. You should use those to ensure that your package will continue to work if the file system layout is changed in the future.\n\n\n\n\ninstalled target '\ntarget\n' is not defined\n\n\n\n\nID\n: undefined_install_target\n\n\nSeverity\n: error\n\n\nExplanation\n: Your package installs a CMake target which is neither a library nor an executable.\n\n\n\n\nlibrary output name '\noutput\n' has redundant 'lib' prefix\n\n\n\n\nID\n: redundant_lib_prefix\n\n\nSeverity\n: notice\n\n\nExplanation\n: Libraries are automatically prefixed with 'lib', so your library will end up with a file name like 'lib\noutput\n.so'. You can use set_target_properties(... PROPERTIES OUTPUT_NAME ...) to give your library a different file name without changing the target name.\n\n\n\n\nline is not indented properly\n\n\n\n\nID\n: indentation\n\n\nSeverity\n: notice\n\n\nExplanation\n: For better readability, each command should be placed on its own line. if() and foreach() bodies should be indented by one or more extra spaces.\n\n\n\n\nlink_directories() must not be used for system depends\n\n\n\n\nID\n: external_link_directory\n\n\nSeverity\n: error\n\n\nExplanation\n: Directories which are added to the search path with link_directories() will not be propagated to dependent packages. Use find_package() or find_library() with the appropriate PATHS or HINTS instead.\n\n\n\n\nlist \nname\n should be sorted\n\n\n\n\nID\n: unsorted_list\n\n\nSeverity\n: notice\n\n\nExplanation\n: The catkin manual recommends that list element be kept in order.\n\n\n\n\nmalformed argument list: \nmsg\n\n\n\n\nID\n: argument_error\n\n\nSeverity\n: warning\n\n\nExplanation\n: You invoked a CMake command with a malformed argument list. Most likely, you forgot to properly quote variables which may be empty or undefined.\n\n\n\n\nmeaningless package description '\ntext\n'\n\n\n\n\nID\n: description_meaningless\n\n\nSeverity\n: notice\n\n\nExplanation\n: Your package description merely consists of typical filler words which do not actually describe the contents of your package in a meaningful way.\n\n\n\n\nmessage dependency '\npkg\n' is not listed as \ntype\n_depend\n\n\n\n\nID\n: missing_msg_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: Your messages depend on another package which is not listed as \ntype\n_depend in your package.xml\n\n\n\n\nmessage dependency '\npkg\n' is not listed in catkin_package()\n\n\n\n\nID\n: missing_msg_catkin\n\n\nSeverity\n: error\n\n\nExplanation\n: Your messages depend on another package which is not in the CATKIN_DEPENDS stanza of your catkin_package() call.\n\n\n\n\nmeta packages must not have \ntype\n_depends\n\n\n\n\nID\n: invalid_meta_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: Meta packages do not contain code or data and are merely dependency lists. As meta packages do neither build nor test anything, the only valid dependency type is the run_depend.\n\n\n\n\nmissing \ncmd\n()\n\n\n\n\nID\n: missing_cmd\n\n\nSeverity\n: error\n\n\nExplanation\n: You failed to call a command that is required for your package to work. Please refer to the catkin build manual for details.\n\n\n\n\nmissing \ntype\n_depend on '\npkg\n'\n\n\n\n\nID\n: missing_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: Your package uses features of another package but you failed to list this dependency in your package.xml\n\n\n\n\nmissing COMPONENTS keyword before '\npkg\n'\n\n\n\n\nID\n: missing_components\n\n\nSeverity\n: error\n\n\nExplanation\n: The find_package(catkin) call can add other catkin packages as dependencies with the COMPONENTS keyword. The find_package() command lists additional packages but has no COMPONENTS keyword.\n\n\n\n\nmissing find_package(\npkg\n)\n\n\n\n\nID\n: missing_find\n\n\nSeverity\n: error\n\n\nExplanation\n: You failed to call find_package() for a dependency of your package.\n\n\n\n\nmissing generate_messages()\n\n\n\n\nID\n: missing_generate_msg\n\n\nSeverity\n: error\n\n\nExplanation\n: The generate_messages() call creates the messages, services, and actions which are declared in your package by add_message_files(), add_service_files(), and add_action_files() respectively.\n\n\n\n\nmissing include_directories(${catkin_INCLUDE_DIRS})\n\n\n\n\nID\n: missing_catkin_include\n\n\nSeverity\n: error\n\n\nExplanation\n: You must add the catkin include paths to your include search list, or you might experience build failures.\n\n\n\n\noperands for operator \nop\n should be quoted strings\n\n\n\n\nID\n: unquoted_string_op\n\n\nSeverity\n: notice\n\n\nExplanation\n: The catkin manual recommends that if() conditions with string operators should have the operands enclosed in double quotes.\n\n\n\n\npackage '\npkg\n' should be listed in catkin_package()\n\n\n\n\nID\n: suggest_catkin_depend\n\n\nSeverity\n: warning\n\n\nExplanation\n: Your package configures another package as build dependency, it is listed as run_depend in your package.xml, and its name suggests that it contains ROS messages. In that case, you must add it to the CATKIN_DEPENDS stanza of your catkin_package()\n\n\n\n\npackage description starts with boilerplate '\ntext\n'\n\n\n\n\nID\n: description_boilerplate\n\n\nSeverity\n: notice\n\n\nExplanation\n: Your package description starts with a number of typical filler words which do not actually describe the contents of your package. Typically, you can simply delete these words from the description, and it will still make sense and be much more concise.\n\n\n\n\npackage exports \nexport\n plugin but does not \ntype\n_depend on '\npkg\n'\n\n\n\n\nID\n: plugin_depend\n\n\nSeverity\n: warning\n\n\nExplanation\n: Your package exports a plugin for another package, but fails to list said package as a dependency.\n\n\n\n\nproject name '\nname\n' differs from package name\n\n\n\n\nID\n: project_name\n\n\nSeverity\n: error\n\n\nExplanation\n: The CMake project name must be identical to the package name. For backwards compatibility reasons, both names should also be identical to the name of the source folder that contains the package.\n\n\n\n\nscript '\nfile\n' has no \ninterpreter\n shebang line\n\n\n\n\nID\n: missing_shebang\n\n\nSeverity\n: error\n\n\nExplanation\n: All \ninterpreter\n scripts need an appropriate shebang line, i.e. the first line has to start with '#!' and needs to name the full path to the \ninterpreter\n executable.\n\n\n\n\nscript '\nscript\n' must be executable\n\n\n\n\nID\n: script_not_executable\n\n\nSeverity\n: error\n\n\nExplanation\n: Your package contains a script file that has to be marked as executable. On Un\nx systems, run 'chmod +x \"\nscript*\"' to set the executable bit.\n\n\n\n\nsubdirectory '\nsubdir\n' contains a subproject\n\n\n\n\nID\n: subproject\n\n\nSeverity\n: warning\n\n\nExplanation\n: Your package has an independent subproject. This can interact with catkin in unusual ways and is strongly discouraged. No further checks are performed in this subdirectory.\n\n\n\n\nsubdirectory '\nsubdir\n' is added a second time\n\n\n\n\nID\n: duplicate_subdir\n\n\nSeverity\n: error\n\n\nExplanation\n: You added another subdirectory with add_subdirectory() multiple times. This can also happen if you accidentally created a loop where subdir A adds subdir B, which adds subdir A again.\n\n\n\n\nsubdirectory '\nsubdir\n' is missing\n\n\n\n\nID\n: missing_subdir\n\n\nSeverity\n: error\n\n\nExplanation\n: You specified a subdirectory which does not exists or is unreadable.\n\n\n\n\nsubdirectory \nsubdir\n is not in package\n\n\n\n\nID\n: external_subdir\n\n\nSeverity\n: error\n\n\nExplanation\n: You added another subdirectory with add_subdirectory(), but the specified path points outside of the package source directory.\n\n\n\n\ntarget '\nexport_target\n' depends on target '\ntarget\n' which is not installed\n\n\n\n\nID\n: uninstalled_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: Your package can be used from the devel space but cannot be installed properly, because one of your installed targets depends on a library from your package that is not installed as well.\n\n\n\n\ntarget '\ntarget\n' has invalid characters in its output file name\n\n\n\n\nID\n: invalid_target_output\n\n\nSeverity\n: error\n\n\nExplanation\n: The output file that your target is supposed to generate contains invalid characters in its name. You probably forget to call set_target_properties(... PROPERTIES OUTPUT_NAME ...)\n\n\n\n\ntarget '\ntarget\n' is not installed\n\n\n\n\nID\n: missing_install_target\n\n\nSeverity\n: warning\n\n\nExplanation\n: Your package can be used from the devel space but cannot be installed properly, because the build target will not be copied to the proper location.\n\n\n\n\ntarget name '\ntarget\n' might not be sufficiently unique\n\n\n\n\nID\n: target_name_collision\n\n\nSeverity\n: notice\n\n\nExplanation\n: The CMake build system requires all target identifiers to be globally unique. For this reason, it is highly recommended that you add the package name as in '${PROJECT_NAME}_target' or '${PROJECT_NAME}/target'. You can use set_target_properties(... PROPERTIES OUTPUT_NAME ...) to give your target a different output file name (which does not have to be unique if it is installed in a package-specific location).\n\n\n\n\ntest_depend '\npkg\n' used without if(CATKIN_ENABLE_TESTING)\n\n\n\n\nID\n: unguarded_test_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: You have used a test dependency without properly guarding it by a if(CATKIN_ENABLE_TESTING) block. You must add a proper build dependency if you wish to use this package even if tests are disabled.\n\n\n\n\nunconfigured build_depend on '\npkg\n'\n\n\n\n\nID\n: unconfigured_build_depend\n\n\nSeverity\n: warning, error\n\n\nExplanation\n: You declare a build dependency on another package but neither call find_package() nor have it listed as catkin component in the find_package(catkin) call.\n\n\n\n\nunconfigured message dependency '\npkg\n'\n\n\n\n\nID\n: unconfigured_msg_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: Your messages depend on another package which is neither find_package()'d nor listed as a component in the find_package(catkin) call.\n\n\n\n\nunknown \ntype\n_depend '\npkg\n'\n\n\n\n\nID\n: unknown_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: The specified dependency is neither a catkin package nor a known system dependency from the rosdep database.\n\n\n\n\nunknown package '\npkg\n'\n\n\n\n\nID\n: unknown_package\n\n\nSeverity\n: error\n\n\nExplanation\n: You have listed a package which is neither a catkin package nor a known system dependency.\n\n\n\n\nunused \ntype\n_depend on '\npkg\n'\n\n\n\n\nID\n: unused_depend\n\n\nSeverity\n: error\n\n\nExplanation\n: You have a listed a package dependency but do not appear to use any of the features it provides.\n\n\n\n\nuse ${PROJECT_NAME} instead of '\nname\n'\n\n\n\n\nID\n: literal_project_name\n\n\nSeverity\n: notice\n\n\nExplanation\n: The catkin manual recommends that you use the ${PROJECT_NAME} variable instead of the literal project name.\n\n\n\n\nuse find_package(\npkg\n) instead of include(Find\npkg\n.cmake)\n\n\n\n\nID\n: find_by_include\n\n\nSeverity\n: error\n\n\nExplanation\n: The FindXXX.cmake modules are intended to be included by the find_package() command.\n\n\n\n\nuse of link_directories() is strongly discouraged\n\n\n\n\nID\n: link_directory\n\n\nSeverity\n: warning\n\n\nExplanation\n: Directories which are added to the search path with link_directories() will not be propagated to dependent packages. You should avoid this command or at least be aware that it might not work as expected in dependent packages.\n\n\n\n\nvariable \nvar\n is modified\n\n\n\n\nID\n: critical_var_append\n\n\nSeverity\n: warning\n\n\nExplanation\n: You have appended extra data to a critical CMake variable. This might break the build on different systems or affect the global catkin workspace in unintended ways.\n\n\n\n\nvariable \nvar\n is modified\n\n\n\n\nID\n: immutable_var\n\n\nSeverity\n: error\n\n\nExplanation\n: You have modified a CMake variable that is initialized by CMake itself and must not be modified under any circumstances.\n\n\n\n\nvariable \nvar\n is overwritten\n\n\n\n\nID\n: critical_var_overwrite\n\n\nSeverity\n: error\n\n\nExplanation\n: You have overwritten a critical CMake variable and its original content is lost. This will most likely break the build on different systems or affect the global catkin workspace in unintended ways.\n\n\n\n\nvariable CMAKE_BUILD_TYPE is overwritten unconditionally\n\n\n\n\nID\n: cmake_build_type\n\n\nSeverity\n: error\n\n\nExplanation\n: If you wish to provide a default value for CMAKE_BUILD_TYPE, make sure that you do not overwrite user preferences. You should guard the set() command with an appropriate if(NOT CMAKE_BUILD_TYPE) block.",
            "title": "Messages"
        },
        {
            "location": "/messages/#catkin_lint-diagnostic-messages",
            "text": "This is a list of all messages which might be shown by  catkin_lint .\nEach diagnostic has a unique ID (such as  catkin_order_violation ),\nwhich you can use to disable certain messages, either with the command line option --ignore ID , or by adding a pragma line  #catkin_lint: ignore ID  at the beginning\nof the CMakeLists.txt file. As a third option, you can add a pragma line  #catkin_lint: ignore_once ID \nright before the offending statement. Use this if you want to ignore a particular instance\nof a problem but still be notified if the same problem occurs someplace else. You may\nalso use  #catkin_lint: report ID  at any point to override a previous  ignore .",
            "title": "catkin_lint diagnostic messages"
        },
        {
            "location": "/messages/#pkg-in-find_packagecatkin-is-not-a-catkin-package",
            "text": "ID : no_catkin_component  Severity : error  Explanation : The find_package(catkin) call can list other catkin packages as dependencies with the COMPONENTS keyword. This is shorter than multiple find_package() calls, but does not work for system dependencies.",
            "title": "'pkg' in find_package(catkin) is not a catkin package"
        },
        {
            "location": "/messages/#cmd-is-called-before-find_packagecatkin",
            "text": "ID : catkin_order_violation  Severity : error  Explanation : Catkin macros cannot be called before catkin has been configured with find_package(catkin).",
            "title": "cmd() is called before find_package(catkin)"
        },
        {
            "location": "/messages/#cmd-is-deprecated",
            "text": "ID : deprecated_rosbuild  Severity : warning, error  Explanation : This construct was intended to facilitate the migration from Rosbuild to Catkin. It is deprecated and should not be used any more.",
            "title": "cmd() is deprecated"
        },
        {
            "location": "/messages/#cmd-is-not-allowed-in-meta-packages",
            "text": "ID : invalid_meta_command  Severity : error  Explanation : Meta packages do not contain code or data and are merely dependency lists with very strict requirements for the format of the CMakeLists.txt file.",
            "title": "cmd() is not allowed in meta packages"
        },
        {
            "location": "/messages/#cmd-needs-missing-directory-directory",
            "text": "ID : missing_directory  Severity : error  Explanation : This catkin command processes a particular directory which is missing from the package source folder.",
            "title": "cmd() needs missing directory 'directory'"
        },
        {
            "location": "/messages/#cmd-needs-missing-file-file",
            "text": "ID : missing_file  Severity : error  Explanation : This catkin command processes a particular file which is missing from the package source folder.",
            "title": "cmd() needs missing file 'file'"
        },
        {
            "location": "/messages/#cmd-should-be-all-lower-case",
            "text": "ID : cmd_case  Severity : notice  Explanation : The catkin manual recommends that all commands be written in lower case.",
            "title": "cmd() should be all lower-case"
        },
        {
            "location": "/messages/#cmd-used-without-ifcatkin_enable_testing",
            "text": "ID : unguarded_test_cmd  Severity : error  Explanation : You have used a test command without properly guarding it by a if(CATKIN_ENABLE_TESTING) block.",
            "title": "cmd() used without if(CATKIN_ENABLE_TESTING)"
        },
        {
            "location": "/messages/#cmd-uses-directory-directory-which-is-not-in-package",
            "text": "ID : external_directory  Severity : warning  Explanation : This catkin command uses a directory which lies outside of the package source folder. While this may work in your particular setup, you cannot assume file locations in general. Use find_path() to detect external locations insteed.",
            "title": "cmd() uses directory 'directory' which is not in package"
        },
        {
            "location": "/messages/#cmd-uses-file-file-which-is-not-in-package",
            "text": "ID : external_file  Severity : warning, error  Explanation : This catkin command uses a file which lies outside of the package source folder. While this may work in your particular setup, you cannot assume file locations in general. Use find_file() to detect external locations insteed.",
            "title": "cmd() uses file 'file' which is not in package"
        },
        {
            "location": "/messages/#export-plugin-file-file-is-not-installed-to-catkin_package_share_destination",
            "text": "ID : plugin_missing_install  Severity : warning, error  Explanation : Your package can be used from the devel space but cannot be installed properly, because a plugin declaration file which is listed in your package.xml is not installed to the correct location.",
            "title": "export plugin file 'file' is not installed to ${CATKIN_PACKAGE_SHARE_DESTINATION}"
        },
        {
            "location": "/messages/#export-plugin-file-reference-must-start-with-prefix",
            "text": "ID : plugin_export_prefix  Severity : error  Explanation : The ${prefix} variable is carefully overloaded to work with both devel space and install space and must be used in all   tags.",
            "title": "export plugin file reference must start with '${prefix}/'"
        },
        {
            "location": "/messages/#export-plugin-refers-to-missing-file-file",
            "text": "ID : plugin_missing_file  Severity : error  Explanation : A plugin declaration file which is listed in your package.xml is missing from the package source folder.",
            "title": "export plugin refers to missing file 'file'"
        },
        {
            "location": "/messages/#first_cmd-is-called-before-second_cmd",
            "text": "ID : order_violation  Severity : error  Explanation : Certain configuration macros must be called in a specific order as specified by the catkin build manual. Failure to do so may lead to improper configuration of the package and build problems.",
            "title": "first_cmd() is called before second_cmd()"
        },
        {
            "location": "/messages/#old_cmd-is-deprecated-use-new_cmd-instead",
            "text": "ID : deprecated_cmd  Severity : error  Explanation : Some macros have been deprecated and replaced by newer versions. Please upgrade your CMakeLists.txt to ensure compatibility with future caktin versions.",
            "title": "old_cmd() is deprecated, use new_cmd() instead"
        },
        {
            "location": "/messages/#type_depend-pkg-is-not-listed-in-catkin_package",
            "text": "ID : missing_catkin_depend  Severity : error  Explanation : You have specified a catkin run dependency but failed to list it in the CATKIN_DEPENDS stanza of the catkin_package() call.",
            "title": "type_depend 'pkg' is not listed in catkin_package()"
        },
        {
            "location": "/messages/#wrong_type_depend-pkg-should-be-a-right_type_depend",
            "text": "ID : wrong_depend  Severity : error  Explanation : You have listed a package as the wrong dependency type. build_depends are needed to build your package (as in compile the declared executables and libraries). run_depends are needed at runtime to run the nodes or use the libraries and exported headers in other projects. buildtool_depends are significant only for cross-compiling; in that case, buildtool_depends are host architecture (and run during the build process) while build_depends are target architecture (and are linked against). test_depends are additional run_depends which only apply to unit tests.",
            "title": "wrong_type_depend 'pkg' should be a right_type_depend"
        },
        {
            "location": "/messages/#cmake-module-old_module-is-deprecated-use-new_module-instead",
            "text": "ID : deprecated_cmake_module  Severity : warning  Explanation : Some CMake modules have been provided by cmake_modules in the past, but are now provided by the system package or CMake itself. Please upgrade your CMakeLists.txt to ensure compatibility with future catkin versions.",
            "title": "CMake module 'old_module' is deprecated, use 'new_module' instead"
        },
        {
            "location": "/messages/#os-error-msg",
            "text": "ID : os_error  Severity : error  Explanation : An operating system error has occured. This is not a linting problem per se but might be caused by a missing or unreadable file.",
            "title": "OS error: msg"
        },
        {
            "location": "/messages/#catkin_metapackage-in-regular-package",
            "text": "ID : catkin_meta_vs_pkg  Severity : error  Explanation : The catkin_metapackage() command signals your intent to declare a meta package, but the package.xml does not contain a   tag.",
            "title": "catkin_metapackage() in regular package"
        },
        {
            "location": "/messages/#catkin_package-exports-non-package-include-path",
            "text": "ID : external_include_path  Severity : error  Explanation : You listed one or more include paths in the INCLUDE_DIRS stanza of your catkin_package() call which are not part of your package. If you want to export include paths of other modules, use find_package(), find_path(), and/or find_library() and add the dependency to the DEPENDS stanza.",
            "title": "catkin_package() exports non-package include path"
        },
        {
            "location": "/messages/#catkin_package-exports-package-include-path-that-is-not-installed",
            "text": "ID : missing_install_include  Severity : warning, error  Explanation : Your package can be used from the devel space but cannot be installed properly, because the header files will not be copied to the proper location.",
            "title": "catkin_package() exports package include path that is not installed"
        },
        {
            "location": "/messages/#catkin_package-exports-pkg-config-module-pkg",
            "text": "ID : exported_pkg_config  Severity : error  Explanation : Although CMake can invoke pkg-config to detect other modules, this does not work well with catkin, as pkg-config may require you to add link directories. Use the results of pkg_check_module() as hint for find_path() and find_library() instead.",
            "title": "catkin_package() exports pkg-config module 'pkg'"
        },
        {
            "location": "/messages/#catkin_package-in-meta-package",
            "text": "ID : catkin_pkg_vs_meta  Severity : error  Explanation : Meta packages use the catkin_metapackage() command to declare a meta package. This performs additional checks and ensures that all requirements are met.",
            "title": "catkin_package() in meta package"
        },
        {
            "location": "/messages/#catkin_package-lists-pkg-as-catkin-package-but-it-is-not",
            "text": "ID : system_as_catkin_depend  Severity : error  Explanation : In your catkin_package() call, you have listed a system dependency in the CATKIN_DEPENDS stanza, but it belongs in the DEPENDS stanza instead.",
            "title": "catkin_package() lists 'pkg' as catkin package but it is not"
        },
        {
            "location": "/messages/#catkin_package-lists-pkg-as-system-package-but-it-is-not",
            "text": "ID : catkin_as_system_depend  Severity : error  Explanation : In your catkin_package() call, you have listed a catkin package in the DEPENDS stanza, but it belongs in the CATKIN_DEPENDS stanza instead.",
            "title": "catkin_package() lists 'pkg' as system package but it is not"
        },
        {
            "location": "/messages/#catkin_package-lists-unconfigured-system-package-pkg",
            "text": "ID : unconfigured_system_depend  Severity : error  Explanation : In order to export a system package as dependency, you must either call find_package( pkg ) first or initialize the  pkg _INCLUDE_DIRS and  pkg _LIBRARIES variables manually.",
            "title": "catkin_package() lists unconfigured system package 'pkg'"
        },
        {
            "location": "/messages/#condition-cond-is-ambiguous",
            "text": "ID : ambiguous_condition  Severity : warning  Explanation : Historically, the if() command will interpret a single token as a variable name and transparently resolve it if possible. Explicit variable references like if(${var}) can lead to incorrect results if ${var} resolves to a different variable name. Use if(var) instead.",
            "title": "condition 'cond' is ambiguous"
        },
        {
            "location": "/messages/#duplicate-cmd",
            "text": "ID : duplicate_cmd  Severity : error  Explanation : You have called this command more than once, but this does not make sense. If the calls use different arguments, consolidate them into a single call, otherwise simply remove the second.",
            "title": "duplicate cmd()"
        },
        {
            "location": "/messages/#duplicate-find_packagepkg",
            "text": "ID : duplicate_find  Severity : error  Explanation : The find_package() searches for a dependency and caches the result. A second call will be silently ignored. In particular, if you specify different arguments to the second call, those will not have any effect at all, which is most likely not what you want.",
            "title": "duplicate find_package(pkg)"
        },
        {
            "location": "/messages/#duplicate-include-path-pkg_include_dirs",
            "text": "ID : duplicate_build_include  Severity : warning  Explanation : Include paths of packages listed in the find_package(catkin) command are added implicitly by the ${catkin_INCLUDE_DIRS} variable. There is no need to add it a second time.",
            "title": "duplicate include path ${pkg_INCLUDE_DIRS}"
        },
        {
            "location": "/messages/#environment-variables-should-not-be-used",
            "text": "ID : env_var  Severity : warning  Explanation : The behavior of your build should not depend on any environment variables.",
            "title": "environment variables should not be used"
        },
        {
            "location": "/messages/#exported-include-path-path-does-not-exist",
            "text": "ID : missing_export_include_path  Severity : error  Explanation : You have listed an invalid include path in the INCLUDE_DIRS stanza of the catkin_package() command.",
            "title": "exported include path 'path' does not exist"
        },
        {
            "location": "/messages/#exported-library-target-cannot-have-different-output-name",
            "text": "ID : export_lib_renamed  Severity : error  Explanation : Due to a limitation of the catkin build system, the catkin_package() library export function will break if the logical target name is not equal to the actual library name.",
            "title": "exported library 'target' cannot have different output name"
        },
        {
            "location": "/messages/#exported-library-target-is-not-a-library",
            "text": "ID : export_lib_not_lib  Severity : error  Explanation : You listed a library in the LIBRARIES stanza of your catkin_package() call, but it really is an executable.",
            "title": "exported library 'target' is not a library"
        },
        {
            "location": "/messages/#exported-library-target-is-not-installed",
            "text": "ID : uninstalled_export_lib  Severity : warning, error  Explanation : Your package can be used from the devel space but cannot be installed properly, because a library that is exported via catkin_package() will not be copied to the proper location.",
            "title": "exported library 'target' is not installed"
        },
        {
            "location": "/messages/#exported-package-include-path-but-no-exported-library",
            "text": "ID : missing_export_lib  Severity : warning  Explanation : Your package exports a package include path and builds at least one library, which suggests that you may want to export the library to other packages as well.",
            "title": "exported package include path but no exported library"
        },
        {
            "location": "/messages/#exported-target-target-is-not-defined",
            "text": "ID : undefined_target  Severity : error  Explanation : Your package provides a CMake target to other packages, but the listed target is not defined at all.",
            "title": "exported target 'target' is not defined"
        },
        {
            "location": "/messages/#extra-arguments-in-cmd",
            "text": "ID : endblock_args  Severity : notice  Explanation : The catkin manual recommends that  cmd  and other end-of-block statements have no arguments. If you have nested blocks, you should indent them properly instead.",
            "title": "extra arguments in cmd()"
        },
        {
            "location": "/messages/#file-script-is-executable-but-not-installed",
            "text": "ID : uninstalled_script  Severity : warning  Explanation : Your package contains a file that is marked as executable but not installed. If it is a script intended to be run (e.g. with rosrun), it will not work outside the devel tree. If it is not an executable script, you should fix the file permissions.",
            "title": "file 'script' is executable but not installed"
        },
        {
            "location": "/messages/#file-setuppy-found-but-no-catkin_python_setup-call",
            "text": "ID : missing_python_setup  Severity : error  Explanation : The catkin_python_setup() call is required to properly configure python modules, and the existing setup.py indicates that your package provides one or more python modules.",
            "title": "file setup.py found but no catkin_python_setup() call"
        },
        {
            "location": "/messages/#find_packagepkg-before-find_packagecmake_modules",
            "text": "ID : missing_cmake_modules  Severity : warning  Explanation : You need to find_package() cmake_modules before you can use one of its custom configuration modules.",
            "title": "find_package(pkg) before find_package(cmake_modules)"
        },
        {
            "location": "/messages/#find_packagepkg-has-no-required-option",
            "text": "ID : missing_required  Severity : warning, error  Explanation : The package cannot build without this dependency, so it should be marked as REQUIRED accordingly. Use if( pkg _FOUND) clauses to use optional packages.",
            "title": "find_package(pkg) has no REQUIRED option"
        },
        {
            "location": "/messages/#generate_messages-called-but-no-message-declared",
            "text": "ID : unused_generate_msg  Severity : warning  Explanation : The generate_messages() call creates the messages, services, and actions which are declared in your package. If your package does not supply any of these, you do not have to call generate_messages() at all.",
            "title": "generate_messages() called but no message declared"
        },
        {
            "location": "/messages/#global-variable-var-should-contain-project-name",
            "text": "ID : global_var_collision  Severity : notice  Explanation : Global variables and options are stored in the cache. You should prefix your variable names with the project name to avoid name collisions with other packages.",
            "title": "global variable 'var' should contain project name"
        },
        {
            "location": "/messages/#include-path-path-is-exported-but-not-used-for-the-build",
            "text": "ID : missing_build_include  Severity : warning  Explanation : You have listed an include path in the INCLUDE_DIRS stanza of the catkin_package() command, but that path is not mentioned in any include_directories() call.",
            "title": "include path 'path' is exported but not used for the build"
        },
        {
            "location": "/messages/#include-paths-path-and-parent_path-are-ambiguous",
            "text": "ID : ambiguous_build_include  Severity : warning  Explanation : You have used two include paths where one is a parent of the other. Thus the same headers can be included with two different include paths which may confuse users. It is recommended that you keep your include paths consistent.",
            "title": "include paths 'path' and 'parent_path' are ambiguous"
        },
        {
            "location": "/messages/#installtype-dest-is-not-one-of-the-catkin__destinations",
            "text": "ID : install_destination  Severity : warning  Explanation : Catkin provides a number of standard variables to specify installation folders. You should use those to ensure that your package will continue to work if the file system layout is changed in the future.",
            "title": "install(type ... dest) is not one of the ${CATKIN_*_DESTINATION}s"
        },
        {
            "location": "/messages/#installed-target-target-is-not-defined",
            "text": "ID : undefined_install_target  Severity : error  Explanation : Your package installs a CMake target which is neither a library nor an executable.",
            "title": "installed target 'target' is not defined"
        },
        {
            "location": "/messages/#library-output-name-output-has-redundant-lib-prefix",
            "text": "ID : redundant_lib_prefix  Severity : notice  Explanation : Libraries are automatically prefixed with 'lib', so your library will end up with a file name like 'lib output .so'. You can use set_target_properties(... PROPERTIES OUTPUT_NAME ...) to give your library a different file name without changing the target name.",
            "title": "library output name 'output' has redundant 'lib' prefix"
        },
        {
            "location": "/messages/#line-is-not-indented-properly",
            "text": "ID : indentation  Severity : notice  Explanation : For better readability, each command should be placed on its own line. if() and foreach() bodies should be indented by one or more extra spaces.",
            "title": "line is not indented properly"
        },
        {
            "location": "/messages/#link_directories-must-not-be-used-for-system-depends",
            "text": "ID : external_link_directory  Severity : error  Explanation : Directories which are added to the search path with link_directories() will not be propagated to dependent packages. Use find_package() or find_library() with the appropriate PATHS or HINTS instead.",
            "title": "link_directories() must not be used for system depends"
        },
        {
            "location": "/messages/#list-name-should-be-sorted",
            "text": "ID : unsorted_list  Severity : notice  Explanation : The catkin manual recommends that list element be kept in order.",
            "title": "list name should be sorted"
        },
        {
            "location": "/messages/#malformed-argument-list-msg",
            "text": "ID : argument_error  Severity : warning  Explanation : You invoked a CMake command with a malformed argument list. Most likely, you forgot to properly quote variables which may be empty or undefined.",
            "title": "malformed argument list: msg"
        },
        {
            "location": "/messages/#meaningless-package-description-text",
            "text": "ID : description_meaningless  Severity : notice  Explanation : Your package description merely consists of typical filler words which do not actually describe the contents of your package in a meaningful way.",
            "title": "meaningless package description 'text'"
        },
        {
            "location": "/messages/#message-dependency-pkg-is-not-listed-as-type_depend",
            "text": "ID : missing_msg_depend  Severity : error  Explanation : Your messages depend on another package which is not listed as  type _depend in your package.xml",
            "title": "message dependency 'pkg' is not listed as type_depend"
        },
        {
            "location": "/messages/#message-dependency-pkg-is-not-listed-in-catkin_package",
            "text": "ID : missing_msg_catkin  Severity : error  Explanation : Your messages depend on another package which is not in the CATKIN_DEPENDS stanza of your catkin_package() call.",
            "title": "message dependency 'pkg' is not listed in catkin_package()"
        },
        {
            "location": "/messages/#meta-packages-must-not-have-type_depends",
            "text": "ID : invalid_meta_depend  Severity : error  Explanation : Meta packages do not contain code or data and are merely dependency lists. As meta packages do neither build nor test anything, the only valid dependency type is the run_depend.",
            "title": "meta packages must not have type_depends"
        },
        {
            "location": "/messages/#missing-cmd",
            "text": "ID : missing_cmd  Severity : error  Explanation : You failed to call a command that is required for your package to work. Please refer to the catkin build manual for details.",
            "title": "missing cmd()"
        },
        {
            "location": "/messages/#missing-type_depend-on-pkg",
            "text": "ID : missing_depend  Severity : error  Explanation : Your package uses features of another package but you failed to list this dependency in your package.xml",
            "title": "missing type_depend on 'pkg'"
        },
        {
            "location": "/messages/#missing-components-keyword-before-pkg",
            "text": "ID : missing_components  Severity : error  Explanation : The find_package(catkin) call can add other catkin packages as dependencies with the COMPONENTS keyword. The find_package() command lists additional packages but has no COMPONENTS keyword.",
            "title": "missing COMPONENTS keyword before 'pkg'"
        },
        {
            "location": "/messages/#missing-find_packagepkg",
            "text": "ID : missing_find  Severity : error  Explanation : You failed to call find_package() for a dependency of your package.",
            "title": "missing find_package(pkg)"
        },
        {
            "location": "/messages/#missing-generate_messages",
            "text": "ID : missing_generate_msg  Severity : error  Explanation : The generate_messages() call creates the messages, services, and actions which are declared in your package by add_message_files(), add_service_files(), and add_action_files() respectively.",
            "title": "missing generate_messages()"
        },
        {
            "location": "/messages/#missing-include_directoriescatkin_include_dirs",
            "text": "ID : missing_catkin_include  Severity : error  Explanation : You must add the catkin include paths to your include search list, or you might experience build failures.",
            "title": "missing include_directories(${catkin_INCLUDE_DIRS})"
        },
        {
            "location": "/messages/#operands-for-operator-op-should-be-quoted-strings",
            "text": "ID : unquoted_string_op  Severity : notice  Explanation : The catkin manual recommends that if() conditions with string operators should have the operands enclosed in double quotes.",
            "title": "operands for operator op should be quoted strings"
        },
        {
            "location": "/messages/#package-pkg-should-be-listed-in-catkin_package",
            "text": "ID : suggest_catkin_depend  Severity : warning  Explanation : Your package configures another package as build dependency, it is listed as run_depend in your package.xml, and its name suggests that it contains ROS messages. In that case, you must add it to the CATKIN_DEPENDS stanza of your catkin_package()",
            "title": "package 'pkg' should be listed in catkin_package()"
        },
        {
            "location": "/messages/#package-description-starts-with-boilerplate-text",
            "text": "ID : description_boilerplate  Severity : notice  Explanation : Your package description starts with a number of typical filler words which do not actually describe the contents of your package. Typically, you can simply delete these words from the description, and it will still make sense and be much more concise.",
            "title": "package description starts with boilerplate 'text'"
        },
        {
            "location": "/messages/#package-exports-export-plugin-but-does-not-type_depend-on-pkg",
            "text": "ID : plugin_depend  Severity : warning  Explanation : Your package exports a plugin for another package, but fails to list said package as a dependency.",
            "title": "package exports export plugin but does not type_depend on 'pkg'"
        },
        {
            "location": "/messages/#project-name-name-differs-from-package-name",
            "text": "ID : project_name  Severity : error  Explanation : The CMake project name must be identical to the package name. For backwards compatibility reasons, both names should also be identical to the name of the source folder that contains the package.",
            "title": "project name 'name' differs from package name"
        },
        {
            "location": "/messages/#script-file-has-no-interpreter-shebang-line",
            "text": "ID : missing_shebang  Severity : error  Explanation : All  interpreter  scripts need an appropriate shebang line, i.e. the first line has to start with '#!' and needs to name the full path to the  interpreter  executable.",
            "title": "script 'file' has no interpreter shebang line"
        },
        {
            "location": "/messages/#script-script-must-be-executable",
            "text": "ID : script_not_executable  Severity : error  Explanation : Your package contains a script file that has to be marked as executable. On Un x systems, run 'chmod +x \" script*\"' to set the executable bit.",
            "title": "script 'script' must be executable"
        },
        {
            "location": "/messages/#subdirectory-subdir-contains-a-subproject",
            "text": "ID : subproject  Severity : warning  Explanation : Your package has an independent subproject. This can interact with catkin in unusual ways and is strongly discouraged. No further checks are performed in this subdirectory.",
            "title": "subdirectory 'subdir' contains a subproject"
        },
        {
            "location": "/messages/#subdirectory-subdir-is-added-a-second-time",
            "text": "ID : duplicate_subdir  Severity : error  Explanation : You added another subdirectory with add_subdirectory() multiple times. This can also happen if you accidentally created a loop where subdir A adds subdir B, which adds subdir A again.",
            "title": "subdirectory 'subdir' is added a second time"
        },
        {
            "location": "/messages/#subdirectory-subdir-is-missing",
            "text": "ID : missing_subdir  Severity : error  Explanation : You specified a subdirectory which does not exists or is unreadable.",
            "title": "subdirectory 'subdir' is missing"
        },
        {
            "location": "/messages/#subdirectory-subdir-is-not-in-package",
            "text": "ID : external_subdir  Severity : error  Explanation : You added another subdirectory with add_subdirectory(), but the specified path points outside of the package source directory.",
            "title": "subdirectory subdir is not in package"
        },
        {
            "location": "/messages/#target-export_target-depends-on-target-target-which-is-not-installed",
            "text": "ID : uninstalled_depend  Severity : error  Explanation : Your package can be used from the devel space but cannot be installed properly, because one of your installed targets depends on a library from your package that is not installed as well.",
            "title": "target 'export_target' depends on target 'target' which is not installed"
        },
        {
            "location": "/messages/#target-target-has-invalid-characters-in-its-output-file-name",
            "text": "ID : invalid_target_output  Severity : error  Explanation : The output file that your target is supposed to generate contains invalid characters in its name. You probably forget to call set_target_properties(... PROPERTIES OUTPUT_NAME ...)",
            "title": "target 'target' has invalid characters in its output file name"
        },
        {
            "location": "/messages/#target-target-is-not-installed",
            "text": "ID : missing_install_target  Severity : warning  Explanation : Your package can be used from the devel space but cannot be installed properly, because the build target will not be copied to the proper location.",
            "title": "target 'target' is not installed"
        },
        {
            "location": "/messages/#target-name-target-might-not-be-sufficiently-unique",
            "text": "ID : target_name_collision  Severity : notice  Explanation : The CMake build system requires all target identifiers to be globally unique. For this reason, it is highly recommended that you add the package name as in '${PROJECT_NAME}_target' or '${PROJECT_NAME}/target'. You can use set_target_properties(... PROPERTIES OUTPUT_NAME ...) to give your target a different output file name (which does not have to be unique if it is installed in a package-specific location).",
            "title": "target name 'target' might not be sufficiently unique"
        },
        {
            "location": "/messages/#test_depend-pkg-used-without-ifcatkin_enable_testing",
            "text": "ID : unguarded_test_depend  Severity : error  Explanation : You have used a test dependency without properly guarding it by a if(CATKIN_ENABLE_TESTING) block. You must add a proper build dependency if you wish to use this package even if tests are disabled.",
            "title": "test_depend 'pkg' used without if(CATKIN_ENABLE_TESTING)"
        },
        {
            "location": "/messages/#unconfigured-build_depend-on-pkg",
            "text": "ID : unconfigured_build_depend  Severity : warning, error  Explanation : You declare a build dependency on another package but neither call find_package() nor have it listed as catkin component in the find_package(catkin) call.",
            "title": "unconfigured build_depend on 'pkg'"
        },
        {
            "location": "/messages/#unconfigured-message-dependency-pkg",
            "text": "ID : unconfigured_msg_depend  Severity : error  Explanation : Your messages depend on another package which is neither find_package()'d nor listed as a component in the find_package(catkin) call.",
            "title": "unconfigured message dependency 'pkg'"
        },
        {
            "location": "/messages/#unknown-type_depend-pkg",
            "text": "ID : unknown_depend  Severity : error  Explanation : The specified dependency is neither a catkin package nor a known system dependency from the rosdep database.",
            "title": "unknown type_depend 'pkg'"
        },
        {
            "location": "/messages/#unknown-package-pkg",
            "text": "ID : unknown_package  Severity : error  Explanation : You have listed a package which is neither a catkin package nor a known system dependency.",
            "title": "unknown package 'pkg'"
        },
        {
            "location": "/messages/#unused-type_depend-on-pkg",
            "text": "ID : unused_depend  Severity : error  Explanation : You have a listed a package dependency but do not appear to use any of the features it provides.",
            "title": "unused type_depend on 'pkg'"
        },
        {
            "location": "/messages/#use-project_name-instead-of-name",
            "text": "ID : literal_project_name  Severity : notice  Explanation : The catkin manual recommends that you use the ${PROJECT_NAME} variable instead of the literal project name.",
            "title": "use ${PROJECT_NAME} instead of 'name'"
        },
        {
            "location": "/messages/#use-find_packagepkg-instead-of-includefindpkgcmake",
            "text": "ID : find_by_include  Severity : error  Explanation : The FindXXX.cmake modules are intended to be included by the find_package() command.",
            "title": "use find_package(pkg) instead of include(Findpkg.cmake)"
        },
        {
            "location": "/messages/#use-of-link_directories-is-strongly-discouraged",
            "text": "ID : link_directory  Severity : warning  Explanation : Directories which are added to the search path with link_directories() will not be propagated to dependent packages. You should avoid this command or at least be aware that it might not work as expected in dependent packages.",
            "title": "use of link_directories() is strongly discouraged"
        },
        {
            "location": "/messages/#variable-var-is-modified",
            "text": "ID : critical_var_append  Severity : warning  Explanation : You have appended extra data to a critical CMake variable. This might break the build on different systems or affect the global catkin workspace in unintended ways.",
            "title": "variable var is modified"
        },
        {
            "location": "/messages/#variable-var-is-modified_1",
            "text": "ID : immutable_var  Severity : error  Explanation : You have modified a CMake variable that is initialized by CMake itself and must not be modified under any circumstances.",
            "title": "variable var is modified"
        },
        {
            "location": "/messages/#variable-var-is-overwritten",
            "text": "ID : critical_var_overwrite  Severity : error  Explanation : You have overwritten a critical CMake variable and its original content is lost. This will most likely break the build on different systems or affect the global catkin workspace in unintended ways.",
            "title": "variable var is overwritten"
        },
        {
            "location": "/messages/#variable-cmake_build_type-is-overwritten-unconditionally",
            "text": "ID : cmake_build_type  Severity : error  Explanation : If you wish to provide a default value for CMAKE_BUILD_TYPE, make sure that you do not overwrite user preferences. You should guard the set() command with an appropriate if(NOT CMAKE_BUILD_TYPE) block.",
            "title": "variable CMAKE_BUILD_TYPE is overwritten unconditionally"
        },
        {
            "location": "/api/",
            "text": "Register your own checks\n\n\ncatkin_lint\n checks are implemented as\nsubmodules, and interact with the main program\nvia callbacks. You can write your own checks for\n\ncatkin_lint\n and load them with the \n-c\n command line option.\n\n\nEach check is included via an entry function which setups\nthe callbacks for the check. The entry function has a single\nparameter \nlinter\n. The Linter object provides the following\nmethods:\n\n\nrequire()\n\n\nlinter.require(check_name)\n\n\n\n\nChecks may depend on the results of other checks.\nThe \nrequire\n method ensures that \ncheck_name\n\nis called exactly once. Circular dependencies of the\nform \nA->B->C->A\n will be detected and cause an\nexception. In particular, tests must not require themselves.\n\n\nadd_init_hook()\n\n\ndef callback(info):\n    ...\n\nlinter.add_init_hook(callback)\n\n\n\n\nRegisters an initialization hook that is called when\nthe lint check for a particular package begins.\n\n\nadd_command_hook()\n\n\ndef callback(info, cmd, args):\n    ...\n\nlinter.add_command_hook(name, callback)\n\n\n\n\nRegisters a command hook that is called each time the\nCMake parser encounters the command \nname\n. The command\nname and a list of its arguments are passed to the callback.\nAll command names are converted to lower-case.\n\n\nadd_final_hook()\n\n\ndef callback(info):\n    ...\n\nlinter.add_final_hook(callback)\n\n\n\n\nRegisters a final hook that is called when the CMake parser\nhas finished parsing the \nCMakeLists.txt\n file.\n\n\nexecute_hook()\n\n\nlinter.execute_hook(info, cmd, args)\n\n\n\n\nExecutes all registered command hooks for \ncmd\n. This is useful\nfor CMake wrapper macros, so you don't have to duplicate all checks\nfor the wrapped call. For example, the \ncuda_add_executable\n\ncommand hook calls the \nadd_executable\n hooks this way.\n\n\nInfo Object\n\n\nFor each linted package, \ncatkin_lint\n creates a\ndedicated info object that is passed to all callbacks.\nThe info object can be used to store relevant data.\nTypically, the init hook is used to initialize check-specific\nvariables in the info object. As a general rule, checks must not\nmodify variables they do not own, and each check must ensure it\nuses unique variable names that do not conflict with other checks.\n\n\nThe following variables are defined by \ncatkin_lint\n itself:\n\n\n\n\nenv\n:\n    A \nCatkinEnvironment\n object that provides information about\n    the ROS environment.\n\n\npath\n:\n    The filesystem path to the package source folder\n\n\nmanifest\n:\n    A \ncatkin_pkg.packages.Package\n object that is created from\n    information in the \npackage.xml\n.\n\n\nfile\n:\n    The currently parsed CMake file, relative to the package source\n    folder. Is either \nCMakeLists.txt\n or an include file. Only\n    valid in command hooks.\n\n\nline\n:\n    The line number of the currently processed CMake command. Only\n    valid in command hooks.\n\n\ncommands\n:\n    A set of all command names that have been encountered up to this point.\n\n\nfind_packages\n:\n    A set of all packages that have been configured with \nfind_package()\n\n    up to this point.\n\n\ntargets\n:\n    A set of all make targets that have been defined up to this point.\n\n\nexecutables\n:\n    A set of all executables that have been defined up to this point.\n\n\nlibraries\n:\n    A set of all libraries that have been defined up to this point.\n\n\nvar\n:\n    A dictionary of all known CMake variables. Note that many variables\n    have mocked values. In particular, the package source and build folder\n    are \n/pkg-source\n and \npkg-build\n respectively.\n\n\n\n\nreport()\n\n\ninfo.report(level, msg_id, **kwargs)\n\n\n\n\nReports a problem to the user. \nlevel\n must be one of\n\ncatkin_lint.linter.ERROR\n, \ncatkin_lint.linter.WARNING\n, or\n\ncatkin_lint.linter.NOTICE\n. The \nmsg_id\n refers to one\nof the defined diagnostic messages. Certain messages have placeholder\nvariables that must be specified, e.g. \ncmd\n for the command name.\n\n\nsource_relative_path()\n\n\ninfo.source_relative_path(path)\n\n\n\n\nReturns a path relative to the package source directory or\nan absolute path if the path is not within the package. Can handle\n\n${CMAKE_CURRENT_SOURCE_DIR}\n correctly.\n\n\nbinary_relative_path()\n\n\ninfo.binary_relative_path(path)\n\n\n\n\nReturns a path relative to the package build directory or\nan absolute path if the path is not inside the build directory. Can handle\n\n${CMAKE_CURRENT_BINARY_DIR}\n correctly.\n\n\nreal_path()\n\n\ninfo.real_path(path)\n\n\n\n\nReturns the actual file system path for relative package path as\nreturned by \nsource_relative_path()\n.\n\n\nis_internal_path()\n\n\ninfo.is_internal_path(path)\n\n\n\n\nReturns \nTrue\n if the path is either below the package source\ndirectory or the package build directory.\n\n\npath_class()\n\n\ninfo.path_class(path)\n\n\n\n\nReturns a value from the \nPathClass\n class, which can be one of\n\nSOURCE\n, \nBINARY\n, \nDISCOVERED\n, or \nOTHER\n.\n\n\nis_valid_path()\n\n\ninfo.is_valid_path(path, valid=[PathClass.SOURCE, PathClass.BINARY, PathClass.DISCOVERED])\n\n\n\n\nReturns \nTrue\n if the path belongs to any of the valid path classes. By default,\nany path is accepted which is either in the source tree, the a built file, or\na path discovered by the appropriate CMake functions such as \nfind_file()\n.\n\n\nis_existing_path()\n\n\ninfo.is_existing_path(path, check=os.path.exists, require_source_folder=False, discovered_path_ok=True)\n\n\n\n\nReturns \nTrue\n if the path is a valid path argument for a catkin command, which\nmeans it's either an existing file or a file that will be generated by \nconfigure_file\n\nor \nadd_custom_command\n. If \ndiscovered_path_ok\n is \nTrue\n, then a path \ndiscovered by \nfind_package()\n, \nfind_path()\n, \nfind_file()\n or \nfind_library()\n\nwill be accepted as well. If \nrequire_source_folder\n is \nTrue\n, then any files\nwhich are not physically located within the source folder will be rejected.\n\n\nis_catkin_install_destination()\n\n\ninfo.is_catkin_install_destination(path, subdir=None)\n\n\n\n\nReturns \nTrue\n if the path points to the install space of\nthe catkin workspace. If \nsubdir\n is not \nNone\n, it checks\nif the path points to the specified subdirectory in the install\nspace.\n\n\nCatkinEnvironment object\n\n\nis_catkin_pkg()\n\n\nenv.is_catkin_pkg(name)\n\n\n\n\nReturns \nTrue\n if \nname\n is a catkin package.\n\n\nis_known_pkg()\n\n\nenv.is_known_pkg(name)\n\n\n\n\nReturns \nTrue\n if \nname\n is a known package.\n\n\nok\n\n\n    env.ok\n\n\n\n\nIs \nTrue\n if the list of ROS dependencies was properly\ninitialized. If it is \nFalse\n, the function \nis_catkin_pkg()\n\nmay return wrong results, so checks for invalid dependencies should\nbe skipped to prevent false positives.",
            "title": "API"
        },
        {
            "location": "/api/#register-your-own-checks",
            "text": "catkin_lint  checks are implemented as\nsubmodules, and interact with the main program\nvia callbacks. You can write your own checks for catkin_lint  and load them with the  -c  command line option.  Each check is included via an entry function which setups\nthe callbacks for the check. The entry function has a single\nparameter  linter . The Linter object provides the following\nmethods:",
            "title": "Register your own checks"
        },
        {
            "location": "/api/#require",
            "text": "linter.require(check_name)  Checks may depend on the results of other checks.\nThe  require  method ensures that  check_name \nis called exactly once. Circular dependencies of the\nform  A->B->C->A  will be detected and cause an\nexception. In particular, tests must not require themselves.",
            "title": "require()"
        },
        {
            "location": "/api/#add_init_hook",
            "text": "def callback(info):\n    ...\n\nlinter.add_init_hook(callback)  Registers an initialization hook that is called when\nthe lint check for a particular package begins.",
            "title": "add_init_hook()"
        },
        {
            "location": "/api/#add_command_hook",
            "text": "def callback(info, cmd, args):\n    ...\n\nlinter.add_command_hook(name, callback)  Registers a command hook that is called each time the\nCMake parser encounters the command  name . The command\nname and a list of its arguments are passed to the callback.\nAll command names are converted to lower-case.",
            "title": "add_command_hook()"
        },
        {
            "location": "/api/#add_final_hook",
            "text": "def callback(info):\n    ...\n\nlinter.add_final_hook(callback)  Registers a final hook that is called when the CMake parser\nhas finished parsing the  CMakeLists.txt  file.",
            "title": "add_final_hook()"
        },
        {
            "location": "/api/#execute_hook",
            "text": "linter.execute_hook(info, cmd, args)  Executes all registered command hooks for  cmd . This is useful\nfor CMake wrapper macros, so you don't have to duplicate all checks\nfor the wrapped call. For example, the  cuda_add_executable \ncommand hook calls the  add_executable  hooks this way.",
            "title": "execute_hook()"
        },
        {
            "location": "/api/#info-object",
            "text": "For each linted package,  catkin_lint  creates a\ndedicated info object that is passed to all callbacks.\nThe info object can be used to store relevant data.\nTypically, the init hook is used to initialize check-specific\nvariables in the info object. As a general rule, checks must not\nmodify variables they do not own, and each check must ensure it\nuses unique variable names that do not conflict with other checks.  The following variables are defined by  catkin_lint  itself:   env :\n    A  CatkinEnvironment  object that provides information about\n    the ROS environment.  path :\n    The filesystem path to the package source folder  manifest :\n    A  catkin_pkg.packages.Package  object that is created from\n    information in the  package.xml .  file :\n    The currently parsed CMake file, relative to the package source\n    folder. Is either  CMakeLists.txt  or an include file. Only\n    valid in command hooks.  line :\n    The line number of the currently processed CMake command. Only\n    valid in command hooks.  commands :\n    A set of all command names that have been encountered up to this point.  find_packages :\n    A set of all packages that have been configured with  find_package() \n    up to this point.  targets :\n    A set of all make targets that have been defined up to this point.  executables :\n    A set of all executables that have been defined up to this point.  libraries :\n    A set of all libraries that have been defined up to this point.  var :\n    A dictionary of all known CMake variables. Note that many variables\n    have mocked values. In particular, the package source and build folder\n    are  /pkg-source  and  pkg-build  respectively.",
            "title": "Info Object"
        },
        {
            "location": "/api/#report",
            "text": "info.report(level, msg_id, **kwargs)  Reports a problem to the user.  level  must be one of catkin_lint.linter.ERROR ,  catkin_lint.linter.WARNING , or catkin_lint.linter.NOTICE . The  msg_id  refers to one\nof the defined diagnostic messages. Certain messages have placeholder\nvariables that must be specified, e.g.  cmd  for the command name.",
            "title": "report()"
        },
        {
            "location": "/api/#source_relative_path",
            "text": "info.source_relative_path(path)  Returns a path relative to the package source directory or\nan absolute path if the path is not within the package. Can handle ${CMAKE_CURRENT_SOURCE_DIR}  correctly.",
            "title": "source_relative_path()"
        },
        {
            "location": "/api/#binary_relative_path",
            "text": "info.binary_relative_path(path)  Returns a path relative to the package build directory or\nan absolute path if the path is not inside the build directory. Can handle ${CMAKE_CURRENT_BINARY_DIR}  correctly.",
            "title": "binary_relative_path()"
        },
        {
            "location": "/api/#real_path",
            "text": "info.real_path(path)  Returns the actual file system path for relative package path as\nreturned by  source_relative_path() .",
            "title": "real_path()"
        },
        {
            "location": "/api/#is_internal_path",
            "text": "info.is_internal_path(path)  Returns  True  if the path is either below the package source\ndirectory or the package build directory.",
            "title": "is_internal_path()"
        },
        {
            "location": "/api/#path_class",
            "text": "info.path_class(path)  Returns a value from the  PathClass  class, which can be one of SOURCE ,  BINARY ,  DISCOVERED , or  OTHER .",
            "title": "path_class()"
        },
        {
            "location": "/api/#is_valid_path",
            "text": "info.is_valid_path(path, valid=[PathClass.SOURCE, PathClass.BINARY, PathClass.DISCOVERED])  Returns  True  if the path belongs to any of the valid path classes. By default,\nany path is accepted which is either in the source tree, the a built file, or\na path discovered by the appropriate CMake functions such as  find_file() .",
            "title": "is_valid_path()"
        },
        {
            "location": "/api/#is_existing_path",
            "text": "info.is_existing_path(path, check=os.path.exists, require_source_folder=False, discovered_path_ok=True)  Returns  True  if the path is a valid path argument for a catkin command, which\nmeans it's either an existing file or a file that will be generated by  configure_file \nor  add_custom_command . If  discovered_path_ok  is  True , then a path \ndiscovered by  find_package() ,  find_path() ,  find_file()  or  find_library() \nwill be accepted as well. If  require_source_folder  is  True , then any files\nwhich are not physically located within the source folder will be rejected.",
            "title": "is_existing_path()"
        },
        {
            "location": "/api/#is_catkin_install_destination",
            "text": "info.is_catkin_install_destination(path, subdir=None)  Returns  True  if the path points to the install space of\nthe catkin workspace. If  subdir  is not  None , it checks\nif the path points to the specified subdirectory in the install\nspace.",
            "title": "is_catkin_install_destination()"
        },
        {
            "location": "/api/#catkinenvironment-object",
            "text": "",
            "title": "CatkinEnvironment object"
        },
        {
            "location": "/api/#is_catkin_pkg",
            "text": "env.is_catkin_pkg(name)  Returns  True  if  name  is a catkin package.",
            "title": "is_catkin_pkg()"
        },
        {
            "location": "/api/#is_known_pkg",
            "text": "env.is_known_pkg(name)  Returns  True  if  name  is a known package.",
            "title": "is_known_pkg()"
        },
        {
            "location": "/api/#ok",
            "text": "env.ok  Is  True  if the list of ROS dependencies was properly\ninitialized. If it is  False , the function  is_catkin_pkg() \nmay return wrong results, so checks for invalid dependencies should\nbe skipped to prevent false positives.",
            "title": "ok"
        }
    ]
}